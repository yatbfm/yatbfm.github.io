<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Keep Studying">
    <meta name="author" content="yatbfm">
    
    <title>
        
            左神算法笔记 |
        
        yatbfm&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/image.png">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
        
            
                
<link rel="stylesheet" href="/css/custom.css">

            
        
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"yatbfm.github.io","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"yatbfm's blog","author":"yatbfm","favicon":"/images/image.png"},"menu":{"Home":"/","Archives":"/archives","Categories":"/categories","Tags":"/tags"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep studying.","hitokoto":true},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":true},"home":{"category":true,"tag":true,"announcement":null},"post":{"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm","copyright_info":true},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":false,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":true,"css":["/css/custom.css"],"js":["/js/custom.js"]},"root":"","source_data":{},"version":"4.1.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
            <a class="site-name border-box" href="/">
               yatbfm&#39;s blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                首页
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                归档
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                
                                分类
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >首页</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags"
                    >标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        左神算法笔记
                    </div>
                

                
                    <div class="post-header border-box">
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">yatbfm</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-09-23 21:39</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Wed Apr 16 2025 07:47:24 GMT+0000">2025-04-16 07:47</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>17.5k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>79 分钟</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <meta name="referrer" content="no-referrer">
<h1 id="时间复杂度和排序算法">1 时间复杂度和排序算法</h1>
<h2 id="交换两个数的写法">1.1 交换两个数的写法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];                                                           </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>异或操作：</p>
<ul>
<li>相同为0，不同为1</li>
<li>a ^ 0 = a</li>
</ul>
<p>满足交换律和结合律。<br>对以上交换方法做解释：</p>
<ul>
<li>第一行：
<ul>
<li><code>arr[i] = arr[i] ^ arr[j];</code></li>
<li><code>arr[j] = arr[j];</code></li>
</ul></li>
<li>第二行：
<ul>
<li><code>arr[i] = arr[i] ^ arr[j];</code></li>
<li><code>arr[j] = arr[i] ^ arr[j] ^ arr[j] = arr[i];</code></li>
</ul></li>
<li>第三行
<ul>
<li><code>arr[i] = arr[i] ^ arr[j] ^ arr[j] = arr[i] ^ arr[j] ^ arr[i] = arr[j];</code></li>
<li><code>arr[j] = arr[i];</code></li>
</ul></li>
</ul>
<p>交换成功。<br>使用以上方法交换的前提是，两个变量指向的内存不能是同一片区域。<br>也就是说对数组进行交换时，交换的下标必须保证不相等。</p>
<h2 id="找到数组中出现奇数次的数字">1.2 找到数组中出现奇数次的数字</h2>
<h3 id="假设只有一种数出现奇数次">1.2.1 假设只有一种数出现奇数次</h3>
<p>根据异或操作的结果，如果数字出现偶数次异或完之后会变成0，奇数次的还是原来本身，最后将0和奇数次的数异或还是它本身。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ^ b ^ c ^ a ^ b ^ b ^ a ^ a ^ c = b;</span><br></pre></td></tr></table></figure>
<p>因此只有一种数的可以直接遍历所有数然后异或，最终结果就是答案。</p>
<h3 id="假设有两种数出现奇数次">1.2.2 假设有两种数出现奇数次</h3>
<p>首先根据异或操作结果，遍历一遍后，所有偶数次的数都会抵消，只剩下两个奇数次的数的异或记为<code>eor = a ^ b</code>，这里<code>eor</code>不为0，因为<code>a</code>和<code>b</code>是两种数，肯定不相等，所以<code>eor</code>肯定不是0，所以可以在<code>eor</code>中找到至少一个二进制位为1，假设这个二进制位为第<code>i</code>位，那么在第<code>i</code>位中，<code>a</code>和<code>b</code>的值一定不相同。<br>可以根据这个第<code>i</code>位的不同将所有数划分为第<code>i</code>位是1的和0的。</p>
<table>
<thead>
<tr>
<th>第<code>i</code><br>位是0</th>
<th>第<code>i</code><br>位是1</th>
</tr>
</thead>
<tbody>
<tr>
<td>others 0</td>
<td>others 1</td>
</tr>
<tr>
<td><code>a</code>(或<code>b</code>)</td>
<td><code>b</code>(或<code>a</code>)</td>
</tr>
</tbody>
</table>
<p>取另一个变量<code>eorp</code>遍历所有第<code>i</code>位是0或者1的，即可划分出<code>a</code>或者<code>b</code>。<br>这里可以知道<code>eorp</code>的值肯定为<code>a</code>或者<code>b</code>。因为<code>others 0</code>或者<code>others 1</code>一定是偶数个，最终会抵消。<br>因此最后将<code>eor ^ eorp</code>可以得到另一个奇数次的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTwiceNum</span><span class="params">(<span class="type">int</span>[] arr)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur : arr) {</span><br><span class="line">        eor ^= cur;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">eorp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur : arr) {</span><br><span class="line">        <span class="keyword">if</span> ((cur &amp; rightOne) == <span class="number">0</span>) {</span><br><span class="line">            eorp ^= cur;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// a = eorp, b = (eor ^ eorp)</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>上述代码中<code>int rightOne = eor &amp; (~eor + 1)</code>，这行代码作用是获取到从右往左第一个不为0的位置上的数，并且让其他位都为0。其中<code>~eor + 1</code>是<code>eor</code>的补码。<br>假设<code>eor = 10001010</code>则<code>~eor + 1 = 01110110</code>异或后<code>= 00000010</code>。<br>需要注意的是<code>if ((cur &amp; rightOne) == 0)</code>这里的条件只能是<code>== 0 \ != 0 \ == rightOne \ != rightOne</code>。因为<code>rightOne</code>其他位都是0，只有某一位是1，所以异或后的结果，只有这一位是0或者1。</p>
<h2 id="插入排序">1.3 插入排序</h2>
<p>插入排序思想：假设<code>0 - i</code>位置的数有序，从<code>i + 1</code>位置向前看，将<code>i + 1</code>位置的数插入到前边有序的数组中使<code>0 - i + 1</code>的数仍然有序。将<code>i + 1</code>的数依次与前一个数比较，如果小于前一个数就交换，然后再与前一个数比较，直到不小于前一个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> {</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) {</span><br><span class="line">            swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里的代码中将比较大小的条件放在了<code>for</code>循环中可以简化代码，同时要注意向前比较时下标不能越界。<code>j</code>指向的前一个数，<code>j + 1</code>指向当前的数，如果条件成立，即前一个数比当前的数大，就交换，交换后<code>j--</code>，然后下一次比较后<code>j</code>指向的仍然是前一个数，<code>j + 1</code>指向的仍然是当前的数。</p>
<h2 id="master公式">1.4 Master公式</h2>
<p>一个递归方法可以表示成如下的递推式：<br><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="24.749ex" height="2.782ex" role="img" focusable="false" viewBox="0 -877 10938.9 1229.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(704,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1093,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1981,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2647.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3703.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(4232.6,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(4936.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mfrac" transform="translate(5325.6,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(382.3,-345) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><rect width="827.9" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(6393.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(7004.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(8004.9,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(8767.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(9156.9,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(975.3,363) scale(0.707)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g><g data-mml-node="mo" transform="translate(10549.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span><br>当<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex;" xmlns="http://www.w3.org/2000/svg" width="9.533ex" height="2.134ex" role="img" focusable="false" viewBox="0 -694 4213.6 943.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mi" transform="translate(1311,-241.4) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g><g data-mml-node="mo" transform="translate(1664.3,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(1831,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(2637.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mi" transform="translate(3693.6,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container></span>时，<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="15.017ex" height="2.497ex" role="img" focusable="false" viewBox="0 -853.7 6637.5 1103.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(704,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1093,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1981,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2647.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3703.6,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(4466.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(4855.6,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(975.3,363) scale(0.707)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g><g data-mml-node="mo" transform="translate(6248.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span><br>当<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex;" xmlns="http://www.w3.org/2000/svg" width="9.533ex" height="2.134ex" role="img" focusable="false" viewBox="0 -694 4213.6 943.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mi" transform="translate(1311,-241.4) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g><g data-mml-node="mo" transform="translate(1664.3,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(1831,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(2637.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="mi" transform="translate(3693.6,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container></span>时，<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="17.961ex" height="2.497ex" role="img" focusable="false" viewBox="0 -853.7 7938.6 1103.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(704,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1093,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1981,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2647.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3703.6,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(4466.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(4855.6,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="TeXAtom" transform="translate(975.3,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mi" transform="translate(1311,-241.4) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g><g data-mml-node="mo" transform="translate(1664.3,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(1831,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g><g data-mml-node="mo" transform="translate(7549.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span><br>当<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex;" xmlns="http://www.w3.org/2000/svg" width="9.533ex" height="2.134ex" role="img" focusable="false" viewBox="0 -694 4213.6 943.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mi" transform="translate(1311,-241.4) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g><g data-mml-node="mo" transform="translate(1664.3,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(1831,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(2637.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3693.6,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container></span>时，<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="20.672ex" height="2.497ex" role="img" focusable="false" viewBox="0 -853.7 9136.8 1103.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(704,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1093,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1981,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2647.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3703.6,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(4466.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(4855.6,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(975.3,363) scale(0.707)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g><g data-mml-node="mi" transform="translate(6415.2,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(7693.2,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(7859.8,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(8747.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></p>
<h2 id="归并排序">1.5 归并排序</h2>
<p>在数组中，每一个数的左边比当前数小的数累加起来，叫做这个数组的小和。例如<code>[1, 3, 2, 4]</code>，1左边没有比当前数小的；3左边有，是1；2左边有，是1；4左边有，是1
3
2，将这些所有加起来，即为小和。<br>解题思路可以利用归并排序，在合并过程中求小和。归并排序代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> {</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 新建临时数组</span></span><br><span class="line">    <span class="type">int</span>[] t = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 对[left, mid]和[mid + 1, right]部分排序</span></span><br><span class="line">    mergeSort(arr, left, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 将两个排序好的部分合并成一个部分</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) {</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) {</span><br><span class="line">            t[k++] = arr[i++];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            t[k++] = arr[j++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// i和j只有一个满足</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) {</span><br><span class="line">        t[k++] = arr[i++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) {</span><br><span class="line">        t[k++] = arr[j++];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将排序好的部分修改回原始数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = left, k = <span class="number">0</span>; i &lt;= right; i++, k++) {</span><br><span class="line">        arr[i] = t[k];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>同时需要转变一下思路，如果这个数的右边有比当前数大的数，那么当前数就会被加起来。<br>例如<code>left = [1, 2, 2, 4]</code>和<code>right = [2, 3, 5]</code>合并时，<code>left[0] &lt; right[0]</code>，可以肯定，<code>right</code>数组中所有的数都比<code>left[0]</code>大，那么<code>right</code>这些数计算时都会加上<code>left[0]</code>，因此<code>left[0]</code>会被计算<code>right.length - 0</code>次。<br>而当合并到<code>left[1] = right[0]</code>时，和普通归并排序的合并过程略有不同，这里需要首先合并<code>right</code>数组，因为如果首先合并<code>left</code>数组，想要找到<code>right</code>数组中比<code>left[1]</code>大的数不太容易了，而首先合并<code>right</code>数组的话，可以让<code>right</code>的下标跳出相等的限制，当<code>right</code>的数比<code>left[1]</code>大，就可以找到有多少数比<code>left[1]</code>大，就可以求出小和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallSum</span><span class="params">(<span class="type">int</span>[] arr)</span> {</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> mergeSort(arr, left, mid) + mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] t = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) {</span><br><span class="line">        <span class="comment">// 这里和归并排序过程不同</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) {</span><br><span class="line">            ret += arr[i] * (right - j + <span class="number">1</span>);</span><br><span class="line">            t[k++] = arr[i++];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            t[k++] = arr[j++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) {</span><br><span class="line">        t[k++] = arr[i++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) {</span><br><span class="line">        t[k++] = arr[j++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i = left, k = <span class="number">0</span>; i &lt;= right; i++, k++) {</span><br><span class="line">        arr[i] = t[k];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">力扣<i class="fas fa-external-link-alt"></i></a>逆序对问题。同样利用归并排序的过程，在归并过程中判断逆序对的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] arr)</span> {</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> reversePairs(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> reversePairs(arr, left, mid) + reversePairs(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="type">int</span>[] t = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) {</span><br><span class="line">        <span class="comment">// 如果arr[i] &gt; arr[j]表明，i位置到mid位置的数都比j位置的数大，因为两个部分都是升序排序的。</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) {</span><br><span class="line">            t[k++] = arr[i++];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            t[k++] = arr[j++];</span><br><span class="line">            ret += mid - i + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) {</span><br><span class="line">        t[k++] = arr[i++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) {</span><br><span class="line">        t[k++] = arr[j++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i = left, k = <span class="number">0</span>; i &lt;= right; i++, k++) {</span><br><span class="line">        arr[i] = t[k];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="快速排序">1.6 快速排序</h2>
<p>这里采用三路排序，选取一个分界值x，然后划分出小于x的，等于x的，大于x的。然后分别对小于x的和大于x的排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 随机选取一个分界值，可以有效减少最差情况</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[left + (<span class="type">int</span>) (Math.random() * (right - left + <span class="number">1</span>))];</span><br><span class="line">    <span class="comment">// 小于x的区间的最右端</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// less + 1到i - 1区间为等于x的区间，同时i会一直遍历待定的数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="comment">// 大于x的区间的最左端</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; more) {</span><br><span class="line">        <span class="comment">// 小于x，将i位置的数和小于x的区间的右端的数交换，并让区间向右扩，i加一，一步完成就是先右扩再交换。</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; x) {</span><br><span class="line">            swap(arr, i++, ++less);</span><br><span class="line">        <span class="comment">// 大于x，将i位置和大于x的区间的左端的数交换，然后让区间左扩，一步完成就是先左扩再交换。这里不让i加一是因为交换后，不知道交换过来的数是大于x等于x还是小于x，需要判断。</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; x) {</span><br><span class="line">            swap(arr, i, --more);</span><br><span class="line">        <span class="comment">// 等于x的，直接i加一。</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 遍历一遍后，less及左边表示小于x的，more及右边表示大于x的</span></span><br><span class="line">    quickSort(arr, left, less);</span><br><span class="line">    quickSort(arr, more, right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// cpp 11随机数数引擎，需要引入random头文件。</span></span><br><span class="line">    <span class="comment">// 随机数范围：0到int最大值，每次启动程序调用生成的随机数序列相同，</span></span><br><span class="line">    <span class="comment">// 如果需要每次启动生成的不同可以设置当前时间为随机种子</span></span><br><span class="line">    default_random_engine e;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> x = arr[<span class="built_in">e</span>() % (right - left + <span class="number">1</span>) + left];</span><br><span class="line">        <span class="type">int</span> less = left - <span class="number">1</span>, more = right + <span class="number">1</span>, i = left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; more) {</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; x) {</span><br><span class="line">                <span class="built_in">swap</span>(arr[++less], arr[i++]);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; x) {</span><br><span class="line">                <span class="built_in">swap</span>(arr[--more], arr[i]);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">quick_sort</span>(arr, left, less);</span><br><span class="line">        <span class="built_in">quick_sort</span>(arr, more, right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="堆">1.7 堆</h2>
<p>大根堆示例如下：</p>
<p><img src="https://cdn.nlark.com/yuque/__mermaid_v3/08b16ae650e0ebb310ac36103a86b2b1.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBUQlxuXHRhKCg5KSkgLS0-IGIoKDYpKVxuXHRhIC0tPiBjKCg1KSlcblx0YiAtLT4gZCgoNCkpXG5cdGIgLS0-IGUoKDMpKSIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvMDhiMTZhZTY1MGUwZWJiMzEwYWMzNjEwM2E4NmIyYjEuc3ZnIiwiaWQiOiI5NjIzZGM4NiIsImNhcmQiOiJkaWFncmFtIn0=#id=L9CJf&amp;originHeight=191&amp;originWidth=154&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="大根堆"><br>每个根节点的值都要比孩子节点的值大，如果实行小根堆，则根节点的值要小于孩子节点的值。</p>
<p>以大根堆为例，主要实现两种操作：</p>
<ul>
<li>插入数据，在最后插入数据，然后依次向上操作，比较当前数和父节点的大小，如果大于父节点，则进行交换，然后父节点再和它的父节点比较。<br>如下图，插入节点10，该系节点和父节点5比较，然后交换，最后和根节点9比较，然后交换。</li>
</ul>
<figure>
<img src="https://cdn.nlark.com/yuque/__mermaid_v3/5db911a8130485cf88cc65d3d74bf246.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBUQlxuXHRhKCg5KSkgLS0-IGIoKDYpKVxuXHRhIC0tPiBjKCg1KSlcblx0YiAtLT4gZCgoNCkpXG5cdGIgLS0-IGUoKDMpKVxuXHRjIC0tPiBmKCg0KSlcblx0YyAtLT4gZygoMTApKVxuXHRzdHlsZSBnIGZpbGw6IHdoaXRlLCBzdHJva2U6ICMzMzNcblx0c3R5bGUgYyBmaWxsOiBwaW5rXG5cdHN0eWxlIGEgZmlsbDogcGluayIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvNWRiOTExYTgxMzA0ODVjZjg4Y2M2NWQzZDc0YmYyNDYuc3ZnIiwiaWQiOiJlOGNhN2FjZSIsImNhcmQiOiJkaWFncmFtIn0=#id=oC8db&amp;originHeight=201&amp;originWidth=276&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="1">
<figcaption aria-hidden="true">1</figcaption>
</figure>
<ul>
<li>删除数据，如删除根节点的数据，可以将最后一个数覆盖掉根节点的数，然后向下操作。找到两个孩子（如果有）的最大值，和父节点进行比较，如果大于父节点，则交换，然后再从这个节点向下操作。<br>基于上一个图，将根节点10删除后的状态应该是最后一个值5替换根节点，最后一个值5会被丢掉，这里用涂黑表示。然后从根节点索引0开始向下堆化操作。这里首先和最大的孩子节点9比较，然后交换。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上操作，堆插入，其中index表示插入的值的索引。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="comment">// 如果当前节点大于父节点，则进行交换，然后将索引更新为父节点索引。</span></span><br><span class="line">    <span class="comment">// 如果一直向上更新到根节点索引为0，0的父节点的索引计算完后还是0，堆插入终止</span></span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) {</span><br><span class="line">        swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 向下操作，堆化，其中index表示需要操作的索引，heapSize表示当前堆的大小。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span> {</span><br><span class="line">    <span class="comment">// 首先获取左孩子的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果有左孩子，这也表示有孩子。</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; heapSize) {</span><br><span class="line">        <span class="comment">// left + 1表示右孩子，如果右孩子存在，并且值大于左孩子，两个孩子最大值的索引就是右孩子。</span></span><br><span class="line">        <span class="comment">// 如果右孩子不存在，或者右孩子值小于左孩子，那么最大值索引就是左孩子。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        <span class="comment">// 比较孩子中的最大值和父节点，如果孩子值大于父节点的值，则赋值。</span></span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="comment">// 如果最大值就是父节点自己本身，则说明满足大根堆，不操作。</span></span><br><span class="line">        <span class="keyword">if</span> (index == largest) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        swap(arr, index, largest);</span><br><span class="line">        <span class="comment">// 继续向下操作。</span></span><br><span class="line">        index = largest;</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> index, left = <span class="number">2</span> * index + <span class="number">1</span>, right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[t]) {</span><br><span class="line">        t = left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[t]) {</span><br><span class="line">        t = right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (t != index) {</span><br><span class="line">        swap(arr, index, t);</span><br><span class="line">        heapify(arr, t, heapSize);</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果要删除堆中的第一个元素也就是根节点，可以直接使用<code>heapify</code>方法，<code>index</code>设为0即可，但这个方法也支持从其他位置向下堆化操作。如果想要删除任意位置的元素：</p>
<ol type="1">
<li>将末尾的值覆盖掉要删除的元素的值。</li>
<li>基于当前位置进行向上或向下操作。
<ol type="1">
<li>如果覆盖的值比原值大，则向上操作。</li>
<li>否则向下操作。</li>
</ol></li>
</ol>
<p>但是可以不必进行判断操作，因为在向上向下操作时，会首先判断是否满足条件，因此可以直接执行一次向上和向下操作即可。</p>
<p><a href="#5.5">堆的应用</a></p>
<h2 id="堆排序扩展题">1.8 堆排序扩展题</h2>
<p>首先给前<code>k+1</code>个数放入小根堆中，那么小根堆的堆顶必然是所有的最小值。因为题目中说移动距离不超过<code>k</code>，那么最小值所在的位置最远是在索引<code>k</code>的位置。取出最小值放入数组，然后往后加入一个元素，选出第二个小的元素，依此类推。具体实现中可以手写堆，也可以使用优先队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortedLessK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> {</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &lt;= Math.min(arr.length, k); index++) {</span><br><span class="line">        heap.add(arr[index]);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &lt; arr.length; index++, i++) {</span><br><span class="line">        arr[i] = heap.poll();</span><br><span class="line">        heap.add(arr[index]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty()) {</span><br><span class="line">        arr[i++] = heap.poll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="基数排序">1.9 基数排序</h2>
<p>待更新...</p>
<h1 id="链表">2 链表</h1>
<h2 id="回文链表的判断">2.1 回文链表的判断</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/description/">回文链表<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="方法一">方法一</h3>
<p>使用栈数据结构，遍历链表压栈，再依次出栈和原链表对比。<br>空间复杂度较高<code>O(N)</code></p>
<h3 id="方法二">方法二</h3>
<p>快慢指针，快指针走到结尾时，慢指针走到中间，慢指针继续向下遍历，遍历过程反转后边的链表，最后从开始和结尾依次向中间遍历，比对。<br>空间复杂度O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) {</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果是奇数，快指针指向最后一个节点</span></span><br><span class="line">        <span class="comment">// 如果是偶数，快指针指向倒数第二个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// slow再往下移动到右半部分的第一个节点。</span></span><br><span class="line">        <span class="comment">// 如果链表长度为偶数，移动后则正好在右半部分第一个；</span></span><br><span class="line">        <span class="comment">// 如果为奇数，那么可以认为中间的数不属于任何部分，他对整体的回文性没有影响，</span></span><br><span class="line">        <span class="comment">// 例如1 2 3 2 1，可以认为1 2 为左部分，2 1 为右部分，slow在右部分第一个节点2上</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="comment">// 保存反转后的链表头节点，为后续恢复链表做准备</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tempSlow</span> <span class="operator">=</span> reverse(slow);</span><br><span class="line">        fast = tempSlow;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (slow.val != fast.val) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 恢复被反转的链表</span></span><br><span class="line">        reverse(tempSlow);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="随机链表的复制">2.2 随机链表的复制</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/description/">LCR
154. 复杂链表的复制 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="方法一-1">方法一</h3>
<p>使用哈希表，保存旧节点和新节点的键值对，然后遍历链表，将节点的下一个节点和随机节点复制。<br>空间复杂度<code>O(N)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    Map&lt;Node, Node&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(temp.val);</span><br><span class="line">        hash.put(temp, copy);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) {</span><br><span class="line">        hash.get(temp).next = hash.get(temp.next);</span><br><span class="line">        hash.get(temp).random = hash.get(temp.random);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> hash.get(head);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="方法二-1">方法二</h3>
<p>首先遍历链表，遍历过程中复制当前节点，然后将复制的节点加入到链表中的当前节点后，直到复制完所有节点。<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/10356726/1713283687533-5cd07d29-7e87-48ee-b11e-8a1fb195690d.jpeg#averageHue=%23f6f6f6&amp;id=KEuXF&amp;originHeight=639&amp;originWidth=3347&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="><br>复制完后，新复制的节点只有<code>next</code>指针有值，而<code>random</code>指针没有值，下一步在这个新链表上操作，将复制的节点的<code>random</code>连接到正确的节点上。因为每一个旧节点a的下一个一定是复制的节点a_copy，所以旧节点a的<code>random</code>指针指向的节点a_random的下一个节点a_random_copy（即复制的节点）就是a_copy的<code>random</code>指针应该指向的节点。如图蓝色的箭头即为复制的节点的<code>random</code>指针的正确指向。<br>实际中需要<strong>注意</strong>：<code>random</code>指针可能指向<code>null</code>，此时需要进行判空操作。<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/10356726/1713369990568-0bfab344-8f2f-484c-9d37-5fe25d5ffdb3.jpeg#averageHue=%23f5f5f5&amp;id=WHRdz&amp;originHeight=816&amp;originWidth=3389&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="><br>最后遍历链表，将新复制的链表拆分出来，然后组成新的链表即可，同时原链表也要恢复原状。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) {</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> {</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(temp.val);</span><br><span class="line">            copy.next = temp.next;</span><br><span class="line">            temp.next = copy;</span><br><span class="line">            temp = temp.next.next;</span><br><span class="line">        }</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">copy</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            copy.random = temp.random == <span class="literal">null</span> ? <span class="literal">null</span> : temp.random.next;</span><br><span class="line">            temp = temp.next.next;</span><br><span class="line">        }</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">headcopy</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">copy</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            temp.next = copy.next;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            copy.next = temp == <span class="literal">null</span> ? <span class="literal">null</span> : temp.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> headcopy;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="判断一个链表是否有环以及返回入环节点">2.3
判断一个链表是否有环，以及返回入环节点</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/description/">环形链表I<i class="fas fa-external-link-alt"></i></a><br><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">环形链表II<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="方法一-2">方法一</h3>
<p>使用哈希表，遍历整个链表，依次存入链表，存入之前判断是否已经存在，如果存在则当前链表为入环的第一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span> &amp;&amp; !set.contains(temp)) {</span><br><span class="line">        set.add(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="方法二-2">方法二</h3>
<p>快慢指针，快指针一次走两步，慢指针一次走一步，如果快指针遇到<code>null</code>则无环，否则当快慢指针相遇时有环，此时让快指针从头节点开始一次一步，慢指针一次一步，当快慢指针再次相遇时，该节点为入环的第一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) {</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) {</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// pos表示fast和slow相遇的位置</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">first</span><span class="params">(ListNode head, ListNode pos)</span> {</span><br><span class="line">        <span class="keyword">while</span> (head != pos) {</span><br><span class="line">            head = head.next;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line"><span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) {</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    <span class="comment">// 当快慢指针相同时，必然有环，因此使fast指针为头指针，快慢指针同时移动，即可找到入环节点</span></span><br><span class="line">    <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) {</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 走到这一步说明快慢指针不相等，并且快指针可以走到头，那说明没环</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="判断两个链表是否相交">2.4 判断两个链表是否相交</h2>
<p>这里认为链表都是单链表</p>
<ol type="1">
<li>情况1：两个链表都无环<br>双指针，遍历链表A和B，当指针为null时从另一个节点的头节点开始遍历。直到两个指针相等（两个指针相等时，如果为null则表示没有相交节点，否则有相交节点）<br><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1395092/lian-biao-xiang-jiao-by-leetcode-solutio-2kne/">面试题
02.07. 链表相交 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> {</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) {</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>❗<strong>注意</strong>：判断是否为<code>null</code>时，使用的是<code>pA</code>当前指针，而不是<code>pA.next</code>，如果使用<code>pA.next</code>来判断，当不相交时，会发生无限循环的情况，<code>pA</code>和<code>pB</code>会一直不相等（也不为<code>null</code>)。所以使用<code>pA</code>当前指针。可以理解为，把最后链表结束时指向的<code>null</code>指针也算作一个节点，然后两个链表不相交时，最后都会指向<code>null</code>节点，那么两个链表就在<code>null</code>节点“相交”了，如下图所示。<br><img src="https://cdn.nlark.com/yuque/__mermaid_v3/be9f1cca97ccfc28c1323ef985ae5a99.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJmbG93Y2hhcnQgTFJcblx0MSAtLS0-IDJcblx0MiAtLS0-IDNcblx0MyAtLS0-IG51bGxcblx0NCAtLS0-IDVcblx0NSAtLS0-IG51bGwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19tZXJtYWlkX3YzL2JlOWYxY2NhOTdjY2ZjMjhjMTMyM2VmOTg1YWU1YTk5LnN2ZyIsImlkIjoiREJMN3AiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9#id=aHzmc&amp;originHeight=134&amp;originWidth=434&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<ol start="2" type="1">
<li>情况2：一个有环一个无环（一定不相交）<br>如果相交，则肯定有一个节点有两个<code>next</code>指针，这不满足单链表。所以一定不相交。</li>
<li>情况3：两个都有环</li>
<li>不相交</li>
<li>在非环处相交</li>
<li>在环处相交</li>
</ol>
<p>相交只有两种情况<br><img src="http://pfmiles.github.io/images/circledLinkedListsIntersections.png#id=oWbz7&amp;originHeight=196&amp;originWidth=308&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=#id=IK96b&amp;originHeight=196&amp;originWidth=308&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="><br>找到两个带环链表的入环节点，然后固定一个，遍历另一个，直到能找到一个节点和固定节点相等，则证明相交，否则不相交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleNode1 circleNode2是两个节点的入环节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果入环节点相同，说明必然是情况1。否则是情况2或者不相交</span></span><br><span class="line"><span class="keyword">if</span> (circleNode1 == circleNode2) {</span><br><span class="line">    <span class="comment">// 利用circleNode1或者2为末尾节点，利用无环链表求相交节点方式求相交的节点。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> circleNode2.next;</span><br><span class="line"><span class="keyword">while</span>(temp != circleNode2) {</span><br><span class="line">    <span class="keyword">if</span>(temp == circleNode1)</span><br><span class="line">        <span class="comment">// circleNode1 或者  circleNode2为相交节点都可以</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    temp = temp.next;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 不相交</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>所以所有情况如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/10356726/1713410727063-91b0fc17-2f99-4a6b-84db-f74393d91bd2.jpeg#averageHue=%23fafafa&amp;id=VgahE&amp;originHeight=543&amp;originWidth=1940&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cycleNodeA</span> <span class="operator">=</span> hasCycle(headA);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cycleNodeB</span> <span class="operator">=</span> hasCycle(headB);</span><br><span class="line">    <span class="keyword">if</span> (cycleNodeA == cycleNodeB) {</span><br><span class="line">        <span class="comment">// 说明两个都是无环的，直接判断是否相交</span></span><br><span class="line">        <span class="comment">// if (cycleNodeA == null) {</span></span><br><span class="line">        <span class="comment">//     return getIntersectionNodeNoLoop(headA, headB, null);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// 否则是都有环，入环节点相同，必然相交，以入环节点为终止节点求相交节点</span></span><br><span class="line">        <span class="comment">// return getIntersectionNodeNoLoop(headA, headB, cycleNodeA);</span></span><br><span class="line">        <span class="comment">// 以上代码可以直接合并为下面一行</span></span><br><span class="line">        <span class="keyword">return</span> getIntersectionNodeNoLoop(headA, headB, cycleNodeA);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 说明两个入环节点不相等，要么有一个为空，要么都不为空，如果有一个为空，则表示肯定不相交</span></span><br><span class="line">    <span class="keyword">if</span> (cycleNodeA == <span class="literal">null</span> || cycleNodeB == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果环上相交，说明从一个入环节点开始遍历，一定能到达另一个入环节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cycleNodeA;</span><br><span class="line">    <span class="keyword">while</span> (temp != cycleNodeB) {</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        <span class="comment">// 转了一圈发现回到原位置了，说明没有相交</span></span><br><span class="line">        <span class="keyword">if</span> (temp == cycleNodeA) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 相交，任意一个入环节点都可以是相交节点。</span></span><br><span class="line">    <span class="keyword">return</span> cycleNodeA;</span><br><span class="line">    <span class="comment">// 如果入环节点不同，并且相交，那么肯定有两个相交节点</span></span><br><span class="line">    <span class="comment">// return cycleNodeB;</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 判断一个链表是否有环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) {</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow) {</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 判断两个无环链表是否相交，手动设定终止节点endNode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getIntersectionNodeNoLoop</span><span class="params">(ListNode headA, ListNode headB, ListNode endNode)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) {</span><br><span class="line">        pA = pA == endNode ? headB : pA.next;</span><br><span class="line">        pB = pB == endNode ? headA : pB.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="找到两个有序链表相同的节点">2.5 找到两个有序链表相同的节点</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/10356726/1713187724179-2f49ebfa-d433-4110-b037-64711e4e758a.png#averageHue=%23eae9ea&amp;clientId=u3de00d8e-cbbf-4&amp;from=paste&amp;height=170&amp;id=ubc05a495&amp;originHeight=212&amp;originWidth=1070&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=147947&amp;status=done&amp;style=none&amp;taskId=u89a34d32-699c-4f7a-a863-03dcbea1e69&amp;title=&amp;width=856#averageHue=%23eae9ea&amp;id=qNjX1&amp;originHeight=212&amp;originWidth=1070&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="><br>解题思路：因为两个链表都是有序的，采用双指针。比较当前值，较小的指针向后移动，如果相等了，加入结果集，同时向后移动，然后继续比较，直到一个越界。<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/10356726/1713189078588-7c7244de-99f0-408a-86ec-aa672f4abcd2.jpeg#averageHue=%23f4f4f4&amp;id=tvzmi&amp;originHeight=616&amp;originWidth=1912&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<h2 id="把链表按某个值分为小于-等于-大于的部分">2.6
把链表按某个值分为小于 等于 大于的部分</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/description/">排序链表<i class="fas fa-external-link-alt"></i></a><br><img src="https://cdn.nlark.com/yuque/0/2024/png/10356726/1713255818758-7134e597-4d67-4c2e-9cea-8b01db62ad2e.png#averageHue=%23e6e8e7&amp;clientId=u59f58a3c-e2ed-4&amp;from=paste&amp;height=362&amp;id=u84e4b1c0&amp;originHeight=452&amp;originWidth=1175&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=485574&amp;status=done&amp;style=none&amp;taskId=u7b32a22d-0544-477c-a23a-10a1266dabd&amp;title=&amp;width=940#averageHue=%23e6e8e7&amp;id=LmV5w&amp;originHeight=452&amp;originWidth=1175&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<h3 id="入门做法">入门做法</h3>
<p>把链表每个<strong>节点(不是值，是节点Node)</strong>放在数组里，然后使用快排中的<code>partition</code>。</p>
<h3 id="高级做法">高级做法</h3>
<p>首先准备6个指针，分别表示：</p>
<table>
<thead>
<tr>
<th>smallHead</th>
<th>小于部分的头指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>smallTail</td>
<td>小于部分的尾指针</td>
</tr>
<tr>
<td>equalHead</td>
<td>等于部分的头指针</td>
</tr>
<tr>
<td>equalTail</td>
<td>等于部分的尾指针</td>
</tr>
<tr>
<td>bigHead</td>
<td>大于部分的头指针</td>
</tr>
<tr>
<td>bigTail</td>
<td>大于部分的尾指针</td>
</tr>
</tbody>
</table>
<p>使用这六个指针分别串联出<strong>小于部分</strong>、<strong>等于部分</strong>、<strong>大于部分</strong>的链表。<br>遍历整个链表，如果遇到小于的节点，加入到<strong>小于部分</strong>的链表中，也就是利用尾插法插入到以<code>smallHead</code>为头结点的链表的末尾，等于、大于的节点同理。<br>最后将小于部分的尾连接到等于部分的头，等于部分的尾连接到大于部分的头。<br>但是在实现时要<strong>注意</strong>：可能不存在<strong>小于部分</strong>或者<strong>等于部分</strong>等等，要对每个进行判空处理，防止出现空指针异常。<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/10356726/1713258054530-fb9c044f-4b14-44cc-8700-a5aa06e31478.jpeg#averageHue=%23f6f6f6&amp;id=R3G9i&amp;originHeight=666&amp;originWidth=932&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">listPartition</span><span class="params">(ListNode head, <span class="type">int</span> pivot)</span> {</span><br><span class="line">    <span class="comment">// 构造三个类分别表示小于部分的链表，等于部分、大于部分的链表</span></span><br><span class="line">    <span class="type">PartitionNode</span> <span class="variable">small</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartitionNode</span>();</span><br><span class="line">    <span class="type">PartitionNode</span> <span class="variable">equal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartitionNode</span>();</span><br><span class="line">    <span class="type">PartitionNode</span> <span class="variable">big</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartitionNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 需要频繁插入节点到尾节点，因此用一个方法包装，减少代码量。</span></span><br><span class="line">        <span class="keyword">if</span> (temp.val &lt; pivot) {</span><br><span class="line">            small.insertTail(temp);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (temp.val &gt; pivot) {</span><br><span class="line">            big.insertTail(temp);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            equal.insertTail(temp);</span><br><span class="line">        }</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 最终需要判断小于部分和等于部分的空值情况。</span></span><br><span class="line">    <span class="comment">// 如果小于部分不为空，然后等于部分不为空，则连接到等于部分，再连接到大于部分，如果等于部分为空，则直接连接到大于部分</span></span><br><span class="line">    <span class="comment">// 如果小于部分为空，等于部分不为空，则连接到大于部分，如果等于部分为空，则说明只有大于部分，直接返回大于部分</span></span><br><span class="line">    <span class="keyword">if</span> (small.head != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (equal.head != <span class="literal">null</span>) {</span><br><span class="line">            small.tail.next = equal.head;</span><br><span class="line">            equal.tail.next = big.head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            small.tail.next = big.head;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> small.head;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (equal.head != <span class="literal">null</span>) {</span><br><span class="line">        equal.tail.next = big.head;</span><br><span class="line">        <span class="keyword">return</span> equal.head;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> big.head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 定义一个类包含头节点和尾节点。</span></span><br><span class="line"><span class="comment">// 算法实现时会频繁在尾部插入节点，会改变头尾指针的值，因此在类中定义头尾指针。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PartitionNode</span> {</span><br><span class="line">    ListNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertTail</span><span class="params">(ListNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">            head = tail = node;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 定义节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="链表快速排序">链表快速排序</h3>
<p>由此引出对链表的快速排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PartitionNode <span class="title function_">quickSortList</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PartitionNode</span>(head, head);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过快慢指针找到中间位置的节点作为中间值，防止边缘特殊情况使算法退化</span></span><br><span class="line">    ListNode pivotNode;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) {</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    }</span><br><span class="line">    pivotNode = slow;</span><br><span class="line">    <span class="comment">// 划分成三部分。</span></span><br><span class="line">    <span class="type">PartitionNode</span> <span class="variable">small</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartitionNode</span>();</span><br><span class="line">    <span class="type">PartitionNode</span> <span class="variable">equal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartitionNode</span>();</span><br><span class="line">    <span class="type">PartitionNode</span> <span class="variable">big</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartitionNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (temp.val &lt; pivotNode.val) {</span><br><span class="line">            small.insertTail(temp);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (temp.val &gt; pivotNode.val) {</span><br><span class="line">            big.insertTail(temp);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            equal.insertTail(temp);</span><br><span class="line">        }</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 划分后对每部分的链表尾节点添加null值，使这三部分链表独立。</span></span><br><span class="line">    <span class="keyword">if</span> (small.head != <span class="literal">null</span>) {</span><br><span class="line">        small.tail.next = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (equal.head != <span class="literal">null</span>) {</span><br><span class="line">        equal.tail.next = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (big.head != <span class="literal">null</span>) {</span><br><span class="line">        big.tail.next = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 递归排序每部分链表</span></span><br><span class="line">    small = quickSortList(small.head);</span><br><span class="line">    big = quickSortList(big.head);</span><br><span class="line">    <span class="comment">// 连接三部分链表。</span></span><br><span class="line">    <span class="keyword">if</span> (small.head != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (equal.head != <span class="literal">null</span>) {</span><br><span class="line">            small.tail.next = equal.head;</span><br><span class="line">            <span class="comment">// 该算法中返回的是完整的链表头节点和尾节点，所以需要确保返回的small的tail对象为整个链表的尾节点</span></span><br><span class="line">            <span class="comment">// 后续该操作同理，否则会导致数据丢失。</span></span><br><span class="line">            small.tail = equal.tail;</span><br><span class="line">            equal.tail.next = big.head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            small.tail.next = big.head;</span><br><span class="line">        }</span><br><span class="line">        small.tail = big.tail == <span class="literal">null</span> ? small.tail : big.tail;</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (equal.head != <span class="literal">null</span>) {</span><br><span class="line">        equal.tail.next = big.head;</span><br><span class="line">        equal.tail = big.tail == <span class="literal">null</span> ? equal.tail : big.tail;</span><br><span class="line">        <span class="keyword">return</span> equal;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> big;</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PartitionNode</span> {</span><br><span class="line">    ListNode head, tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertTail</span><span class="params">(ListNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">            head = tail = node;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PartitionNode</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PartitionNode</span><span class="params">(ListNode head, ListNode tail)</span> {</span><br><span class="line">        <span class="built_in">this</span>.head = head;</span><br><span class="line">        <span class="built_in">this</span>.tail = tail;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="链表归并排序">链表归并排序</h3>
<p>对于链表的排序，使用归并排序是更好的选择，可以采用更少的代码完成，同时可以使用迭代的方式优化排序，使空间复杂度<code>O(logn)</code>优化为<code>O(1)</code>。<br>这里先使用递归形式的归并排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeSort</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用快慢指针找到中点，如果是奇数个，中点是正中间，如果是偶数，中点是中间两个数的左边的</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) {</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 保存慢指针向后移动一个的指针，作为右半部分的起点</span></span><br><span class="line">    <span class="comment">// 同时让慢指针的next指向null，表示左半部分和右半部分分成了两个链表。</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow.next;</span><br><span class="line">    slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 拆分</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> mergeSort(head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> mergeSort(mid);</span><br><span class="line">    <span class="comment">// 左右分别排序后，进行归并，这里使用尾插法，保证稳定性。</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> ret;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (left.val &lt;= right.val) {</span><br><span class="line">            tail.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            tail.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        }</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 有一个链表没遍历完，放到最后即可。</span></span><br><span class="line">    tail.next = left == <span class="literal">null</span> ? right : left;</span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>❗空间复杂度<code>O(1)</code>的待更新</p>
<h1 id="二叉树">3 二叉树</h1>
<h2 id="遍历">3.1 遍历</h2>
<p>递归、非递归的前中后序遍历要会写。</p>
<h3 id="前中后序遍历非递归">3.1.1 前中后序遍历（非递归）</h3>
<ol type="1">
<li>前序遍历</li>
</ol>
<p>首先设置一个栈结构用于存储。整体遍历流程如下：<br><img src="https://cdn.nlark.com/yuque/__mermaid_v3/fc0f823afef9fda5d453e2b9ac9f4a28.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBMUlxuICAgICAgQVtTdGFydF0gLS0-IEJb5Y6L5YWl5qC56IqC54K5XVxuXHRcdFx0QiAtLT4gQ3vmoIjnqbo_fVxuXHRcdFx0QyAtLT4gfE5vfCBEW-WHuuagiF1cblx0XHRcdEQgLS0-IEVb5omT5Y2wXVxuXHRcdFx0RSAtLT4gRlvlj7PlranlrZDkuI3kuLrnqbrlhaXmoIhdXG5cdFx0XHRGIC0tPiBIW-W3puWtqeWtkOS4jeS4uuepuuWFpeagiF1cblx0XHRcdEggLS0-IENcblx0XHRcdEMgLS0-IHxZZXN8IEdbRW5kXSIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvZmMwZjgyM2FmZWY5ZmRhNWQ0NTNlMmI5YWM5ZjRhMjguc3ZnIiwiaWQiOiJwNENyaCIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sIndpZHRoTW9kZSI6Im5vcm1hbCIsImNhcmQiOiJkaWFncmFtIn0=#id=ynrGk&amp;originHeight=171&amp;originWidth=963&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=">❗上述过程要<strong>注意</strong>：加入孩子节点时一定是先加入右孩子，再加入左孩子，因为栈是后进先出的顺序，所以要后加入左孩子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderUnRecur</span><span class="params">(Tree root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack&lt;Tree&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">        <span class="type">Tree</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.print(pop.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(pop.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(pop.left);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>后序遍历</li>
</ol>
<p>前序遍历的顺序是：根左右，后序遍历的顺序是：左右根。假设现在有前序'（前序撇）遍历：根右左，那么将这个前序'遍历的顺序加入到另一个栈中，最后统一输出，根据栈的现先进后出顺序，那么输出的结果是：左右根。这就是后序遍历的做法。<br>❗有一点<strong>注意</strong>：前序遍历时保证根左右的顺序，加入子孩子时先加入的右孩子，而现在需要根据前序遍历得到前序'遍历即根右左的顺序，因此需要先加入左孩子。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderUnRecur</span><span class="params">(Tree root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack&lt;Tree&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 该栈用于收集结果，最后统一将节点输出，满足后序遍历结果</span></span><br><span class="line">    Stack&lt;Tree&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack1.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack1.isEmpty()) {</span><br><span class="line">        <span class="type">Tree</span> <span class="variable">pop</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">        <span class="comment">// 暂时不打印，首先加入到结果栈中</span></span><br><span class="line">        stack2.push(pop);</span><br><span class="line">        <span class="comment">// 先加入左孩子，保证在加入结果栈时可以先出</span></span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) {</span><br><span class="line">            stack1.push(pop.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) {</span><br><span class="line">            stack1.push(pop.right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 统一输出</span></span><br><span class="line">    <span class="keyword">while</span> (!stack2.isEmpty()) {</span><br><span class="line">        System.out.print(stack2.pop().val + <span class="string">" "</span>);</span><br><span class="line">    }</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>中序遍历</li>
</ol>
<p>中序遍历顺序：左根右。算法流程：</p>
<ol type="1">
<li>如果左孩子不为空，压栈，将新压入的节点设置为“当前节点”继续执行a</li>
<li>如果左孩子为空，弹出栈，打印</li>
<li>将弹出栈的节点的右孩子设置为“当前节点”，继续执行a</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">midOrderUnRecur</span><span class="params">(Tree root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack&lt;Tree&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置一个指针指向当前遍历到哪个节点，也可以复用root指针</span></span><br><span class="line">    <span class="type">Tree</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// temp != null这个条件是必要的</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || temp != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 如果当前指针不为null，压栈</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(temp);</span><br><span class="line">            <span class="comment">// 将当前指针指向左孩子</span></span><br><span class="line">            temp = temp.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 说明左孩子为空了，出栈</span></span><br><span class="line">        temp = stack.pop();</span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        System.out.print(temp.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 将当前指针指向右孩子，重复上述操作</span></span><br><span class="line">        temp = temp.right;</span><br><span class="line">    }</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>❗中序遍历和前边的前序后序遍历代码区别较大，增加了一个指针指向当前遍历到了哪个节点，而且<code>while</code>循环条件中的<code>temp != null</code>是必需的，因为当栈空的时候，指针可能指向了根节点的右孩子，此时还没有遍历完，需要这个条件，防止丢失数据。</p>
<h3 id="层序遍历">3.1.2 层序遍历</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(Tree root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;Tree&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        <span class="type">Tree</span> <span class="variable">remove</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">        System.out.print(remove.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span> (remove.left != <span class="literal">null</span>) {</span><br><span class="line">            queue.add(remove.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (remove.right != <span class="literal">null</span>) {</span><br><span class="line">            queue.add(remove.right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="求二叉树一层最多的节点个数每一层的节点个数">3.2
求二叉树一层最多的节点个数（每一层的节点个数）</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">LeetCode
102<i class="fas fa-external-link-alt"></i></a><br>使用一个变量保存当前层的个数，然后一次性弹出当前层所有的节点，同时加入所有下一层的节点，这样可以保证每次弹出的节点都是同一层的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMaxLevelNodes</span><span class="params">(Tree root)</span> {</span><br><span class="line">    Queue&lt;Tree&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        <span class="comment">// size即为当前层的节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        maxCnt = Math.max(maxCnt, size);</span><br><span class="line">        <span class="comment">// 一次弹出完该层所有的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">Tree</span> <span class="variable">remove</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (remove.left != <span class="literal">null</span>) {</span><br><span class="line">                queue.add(remove.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (remove.right != <span class="literal">null</span>) {</span><br><span class="line">                queue.add(remove.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxCnt;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最大宽度">3.3 二叉树的最大宽度</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/description/">二叉树最大宽度<i class="fas fa-external-link-alt"></i></a><br>这道题需要加上两个非空节点中间的<code>null</code>节点的数量，可以按照完全二叉树对数进行编号，然后使用<code>最右端的非空节点索引减去最左端非空节点的索引+1</code>即可得到这一层的宽度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义实现Pair类，用于存储节点和对应的索引值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, V&gt; {</span><br><span class="line">    T key;</span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T key, V value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(Tree root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;Pair&lt;Tree, Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储根节点和索引</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(root, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        <span class="comment">// 按照求每层节点个数的方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">// 记录每层节点的最小索引和最大索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> Integer.MAX_VALUE, maxIndex = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            Pair&lt;Tree, Integer&gt; pair = queue.remove();</span><br><span class="line">            <span class="type">Tree</span> <span class="variable">node</span> <span class="operator">=</span> pair.key;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> pair.value;</span><br><span class="line">            minIndex = Math.min(minIndex, index);</span><br><span class="line">            maxIndex = Math.max(maxIndex, index);</span><br><span class="line">            <span class="comment">// 左孩子索引为当前索引 * 2 + 1</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(node.left, <span class="number">2</span> * index + <span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 右孩子索引为当前索引 * 2 + 2</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(node.right, <span class="number">2</span> * index + <span class="number">2</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        maxCnt = Math.max(maxCnt, maxIndex - minIndex + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxCnt;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="判断是否是完全二叉树">3.4 判断是否是完全二叉树</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/description/">LeetCode
958<i class="fas fa-external-link-alt"></i></a><br><strong>方法1：</strong>分两种情况：</p>
<ol type="1">
<li>对于任一个节点，如果有右孩子但无左孩子，直接返回<code>false</code></li>
<li>在条件1不违反的条件下，如果遇到了第一个左右孩子不全的，如只有左孩子或者没有孩子，那么之后的节点必须全部是叶节点。</li>
</ol>
<p>☆<strong>方法2：</strong>层序遍历时将为<code>null</code>的节点也加入进去，如果出现<code>null</code>后，后续出现的节点都要是<code>null</code>否则就不是完全二叉树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">// 设置标记为表示是否出现了null节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果node不为null,但是flag为true,说明之前出现过null节点,就不是完全二叉树了</span></span><br><span class="line">            <span class="keyword">if</span> (flag) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="判断满二叉树">3.5 判断满二叉树</h2>
<p>满二叉树的特征：</p>
<ul>
<li>每一层的节点个数=<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="21.816ex" height="2.497ex" role="img" focusable="false" viewBox="0 -853.7 9642.6 1103.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(576,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(1042,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1387,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(1864,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(2440,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2563.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2952.6,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(3528.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(3994.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4339.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(4816.6,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(5392.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(5753.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">从</text></g><g data-mml-node="mn" transform="translate(6753.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mi" transform="translate(7253.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">开</text></g><g data-mml-node="mi" transform="translate(8253.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">始</text></g><g data-mml-node="mo" transform="translate(9253.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></li>
<li>按照完全二叉树的索引编号，最后一个节点的编号为：<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="27.757ex" height="2.497ex" role="img" focusable="false" viewBox="0 -853.7 12268.7 1103.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(576,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(1042,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1387,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(1864,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(2440,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(2801,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3579,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mo" transform="translate(3689.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4689.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(5189.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5578.7,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(6154.7,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(6620.7,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6965.7,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(7442.7,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(8018.7,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(8379.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">从</text></g><g data-mml-node="mn" transform="translate(9379.7,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mi" transform="translate(9879.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">开</text></g><g data-mml-node="mi" transform="translate(10879.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">始</text></g><g data-mml-node="mo" transform="translate(11879.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></li>
</ul>
<p>本题从每一层节点个数判断，从<a href="#gVbHD">3.2
求二叉树一层最多的节点个数</a>复用代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isFullBiTree</span><span class="params">(Tree root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 记录高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;Tree&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">// 判断当前层节点个数是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (size != Math.pow(<span class="number">2</span>, height)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">Tree</span> <span class="variable">node</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        height++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="判断平衡二叉树">3.6 判断平衡二叉树</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/description/">LeetCode
110<i class="fas fa-external-link-alt"></i></a><br>通过求两个子树的高度过程中判断是否是平衡的。<br>类似于后序遍历。如果子树都不是平衡的，那么整棵树一定不是平衡的。通过设立标志位返回值判断是否是平衡的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="comment">// 如果高度返回-1，说明子树已经是不平衡的了，那么该棵树也是不平衡的。</span></span><br><span class="line">        <span class="comment">// 如果高度都不是-1，说明子树平衡，然后判断整棵树，如果整棵树也不平衡那么返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="判断是否是二叉搜索树">3.7 判断是否是二叉搜索树</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/description/">LeetCode
98<i class="fas fa-external-link-alt"></i></a><br>利用二叉搜索树的定义，中序遍历时判断上一个数是否小于当前的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储中序遍历的上一个遍历到的值,使用Long类型最小值,Integer类型最小值会越界</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果左数不满足条件,整棵树肯定不满足,直接退出</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">    <span class="keyword">if</span> (!left) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果上一个数不小于当前的,说明也不满足</span></span><br><span class="line">    <span class="keyword">if</span> (pre &gt;= root.val) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 重置pre,方便下次使用</span></span><br><span class="line">    pre = root.val;</span><br><span class="line">    <span class="comment">// 判断右树</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="找到二叉树两个节点的最低公共祖先节点">3.8
找到二叉树两个节点的最低公共祖先节点</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">LeetCode
236<i class="fas fa-external-link-alt"></i></a><br><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solutions/240096/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">236.
二叉树的最近公共祖先 -
力扣（LeetCode）题解<i class="fas fa-external-link-alt"></i></a><br>遍历节点，当前节点如果为<code>null</code>或者<code>p``q</code>直接返回。否则遍历左右子树。分别获取到左右子树的返回值。</p>
<ul>
<li>如果左子树返回空，说明左子树肯定不存在<code>p``q</code>，直接返回<code>right</code>因为必然存在在<code>right</code>中。</li>
<li>如果左子树返回不空右子树返回空，则说明肯定存在在左子树中，返回<code>left</code>。</li>
<li>如果都不空，说明左右子树都存在分别存在<code>p``q</code>，则当前<code>root</code>为公共祖先，返回当前的<code>root</code>为公共祖先。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树的中序后继">3.9 二叉搜索树的中序后继</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/P5rCT8/description/">LeetCode
053<i class="fas fa-external-link-alt"></i></a><br>视频讲解：<a class="link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?t=6836.7&amp;p=8">6.
图_哔哩哔哩_bilibili<i class="fas fa-external-link-alt"></i></a>（二叉树的中序后继），二叉搜索树可看作是特殊情况<br>首先根据中序遍历的顺序：左根右，一个节点的后续节点是右子树的最左端的节点。<br>所以如果要查找的节点有右子树，那么直接遍历到右子树的最左端节点，即为后续节点。<br>如果没有右子树，那么后续节点一定在该节点的祖先节点上。因为以当前节点为根的子树没有右子树，说明当前节点子树遍历完了，后续节点一定在某个祖先节点或者没有后续节点。<br><img src="https://cdn.nlark.com/yuque/__mermaid_v3/d2bfc22a119ec3ee36b68c550958b135.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJmbG93Y2hhcnQgVERcbmEoKGEpKSAtLT4gYigoYikpXG5hIC0tPiBwKChwKSlcbnAgLS0-IGMoKGMpKVxucCAtLT4gZCgoZCkpXG5kIC0tPiBlKChlKSlcbmQgLS0-IGYoKGYpKVxuc3R5bGUgcCBmaWxsOiBwaW5rXG5cbmExKChhKSkgLS0-IGIxKChiKSlcbmExIC0tPiBjMSgoYykpXG5iMSAtLT4gcDEoKHApKVxuYjEgLS0-IGQxKChkKSlcbnN0eWxlIHAxIGZpbGw6IHBpbmtcblxuYTIoKGEpKSAtLT4gYjIoKGIpKVxuYTIgLS0-IGMyKChjKSlcbmIyIC0tPiBkMigoZCkpXG5iMiAtLT4gcDIoKHApKVxuc3R5bGUgcDIgZmlsbDogcGluayIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvZDJiZmMyMmExMTllYzNlZTM2YjY4YzU1MDk1OGIxMzUuc3ZnIiwiaWQiOiJUM2FJQSIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=#id=Q98Un&amp;originHeight=266&amp;originWidth=490&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<p>如上图，第一种情况的后续节点是e，第二种后续节点是b，第三种后续节点是a。针对情况2和3即待查找节点p没有右子树的情况下：</p>
<ul>
<li>如果p在根节点的左子树中，那么根节点可能就是p的后续节点，后续节点也可能是根节点的左子树中。</li>
<li>如果p在根节点的右子树中，那么根节点就不是p的后续节点</li>
</ul>
<p>那么怎么判断p在根节点的左子树还是右子树呢？这就用到了二叉搜索树的性质，如果p节点的值比根节点小那么p就在根节点左子树中，否则在右子树。<br>所以算法如下：</p>
<ul>
<li>首先判断有没有右子树，如果有则直接找到右子树最左端节点返回。如果没有则执行下边操作</li>
<li>从根节点开始遍历，依次和p比较，判断p在根节点的哪个子树中
<ul>
<li>如果在左子树中，更新保存答案的变量，继续左子树</li>
<li>如果在右子树中，不更新，直接遍历右子树</li>
<li>直接遍历到最后为<code>null</code></li>
</ul></li>
<li>返回结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p.right != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> p.right;</span><br><span class="line">        <span class="keyword">while</span> (temp.left != <span class="literal">null</span>) {</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 如果p的值大于等于当前根节点的值，说明p在右子树中，当前节点肯定不会是后续节点，所以直接遍历右子树</span></span><br><span class="line">        <span class="comment">// 如果p的值小于当前根节点的值，说明p在左子树中，根据中序遍历顺序：左根右，当前根节点可能是后续节点，</span></span><br><span class="line">        <span class="comment">// 因此先保存当前节点为答案，然后继续遍历左子树（左子树中可能存在真正的后续节点）</span></span><br><span class="line">        <span class="keyword">if</span> (temp.val &lt;= p.val) {</span><br><span class="line">            temp = temp.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ret = temp;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的序列化与反序列化">3.10 二叉树的序列化与反序列化</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?t=7434.7&amp;p=8">B站视频<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="判断是否是二叉树">3.11 判断是否是二叉树</h2>
<p>给定n个节点和m条有向边，节点从[0, n - 1]表示，m条边使用(a,
b)的数对（a指向b）表示为b的父节点是a。判断给定的结果是不是二叉树。<br>🍬思路：<br>将二叉树看成是一个<strong>有向图</strong>，除根节点外每个节点的<strong>入度为1</strong>、<strong>出度小于等于2</strong>，根节点的<strong>入度必须为0</strong>、<strong>出度小于等于2</strong>且只有<strong>一个根节点</strong>，同时保证从根节点出发可以<strong>遍历到所有的节点</strong>。<br>可能存在的图的情况：</p>
<ol type="1">
<li>正确 <img src="https://cdn.nlark.com/yuque/__mermaid_v3/a3783abf17c11242e6994cf6d397fd30.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBURFxuYTEoKCApKSAtLT4gYjEoKCApKVxuYTEoKCApKSAtLT4gYzEoKCApKVxuYjEgLS0-IGQoKCApKVxuYjEgLS0-IGUoKCApKSIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvYTM3ODNhYmYxN2MxMTI0MmU2OTk0Y2Y2ZDM5N2ZkMzAuc3ZnIiwiaWQiOiJtaVlFciIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0="></li>
<li>出度不满足条件 <img src="https://cdn.nlark.com/yuque/__mermaid_v3/315d8841d060b55a7c183951532a05b7.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBURFxuYSgoICkpIC0tPiBiKCggKSlcbmEgLS0-IGMoKCApKVxuYSAtLT4gZCgoICkpIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fbWVybWFpZF92My8zMTVkODg0MWQwNjBiNTVhN2MxODM5NTE1MzJhMDViNy5zdmciLCJpZCI6Im1jNTEyIiwibWFyZ2luIjp7InRvcCI6dHJ1ZSwiYm90dG9tIjp0cnVlfSwiY2FyZCI6ImRpYWdyYW0ifQ=="></li>
<li>入度不满足条件</li>
</ol>
<p>树中存在父子节点之间“互为父子”，则可以从出入度判断不满足条件 <img src="https://cdn.nlark.com/yuque/__mermaid_v3/0c4b8c82ae5c5691e68bd2bc0002b3f2.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBURFxuYSgoICkpIC0tPiBiKCggKSlcbmEgLS0-IGMoKCApKVxuYiAtLT4gZCgoICkpXG5jIC0tPiBkKCggKSlcbuaIllxuYTEoKCApKSAtLT4gYjEoKCApKVxuYTEgLS0-IGMxKCggKSlcbmIxIC0tPiBkMSgoICkpXG5kMSAtLT4gYjEiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19tZXJtYWlkX3YzLzBjNGI4YzgyYWU1YzU2OTFlNjhiZDJiYzAwMDJiM2YyLnN2ZyIsImlkIjoiZDh1RGQiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9">
4. 根节点个数不满足条件</p>
<p>根节点个数大于1 <img src="https://cdn.nlark.com/yuque/__mermaid_v3/d58640032d615a479250423ea5355f8c.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBURFxuYSgoICkpIC0tPiBiKCggKSlcbmEgLS0-IGMoKCApKVxuYTEoKCApKSAtLT4gYjEoKCApKSIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvZDU4NjQwMDMyZDYxNWE0NzkyNTA0MjNlYTUzNTVmOGMuc3ZnIiwiaWQiOiJ1UmdHWiIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=">根节点个数为0
<img src="https://cdn.nlark.com/yuque/__mermaid_v3/e557619ba6781d08efa582ed496ee258.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBURFxuYSgoICkpIC0tPiBiKCggKSlcbmIgLS0-IGFcbuaIllxuYTEoKCApKSAtLT4gYTEiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19tZXJtYWlkX3YzL2U1NTc2MTliYTY3ODFkMDhlZmE1ODJlZDQ5NmVlMjU4LnN2ZyIsImlkIjoiaUs0aEEiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9">
5. 从根节点遍历不能遍历到所有节点</p>
<p>从出入度判断，只有一个入度为0的节点，所以无法从入度为0的个数判断图是否连通，需要使用dfs遍历
<img src="https://cdn.nlark.com/yuque/__mermaid_v3/fbe3081e13f5182b203e45dc5f82647c.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBURFxuYSgoICkpIC0tPiBiKCggKSlcbmIgLS0-IGFcbmMoKCApKSAtLT4gZCgoICkpIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fbWVybWFpZF92My9mYmUzMDgxZTEzZjUxODJiMjAzZTQ1ZGM1ZjgyNjQ3Yy5zdmciLCJpZCI6ImptNkNXIiwibWFyZ2luIjp7InRvcCI6dHJ1ZSwiYm90dG9tIjp0cnVlfSwiY2FyZCI6ImRpYWdyYW0ifQ==">因此根据上述条件总结出算法流程：<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/10356726/1719757113802-cb96064a-9061-44c5-9e74-0e34bb7c57a2.jpeg"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;g, <span class="type">int</span> t, <span class="type">bool</span> *st)</span> </span>{</span><br><span class="line">    st[t] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[t].<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="keyword">if</span> (!st[g[t][i]]) {</span><br><span class="line">            <span class="built_in">dfs</span>(g, g[t][i], st);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 判断是否是二叉树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBinaryTree</span><span class="params">(<span class="type">int</span> n, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;edges)</span> </span>{</span><br><span class="line">    <span class="comment">// 构造图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        g[edges[i].first].<span class="built_in">push_back</span>(edges[i].second);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 求出入度</span></span><br><span class="line">    <span class="type">int</span> inDegree[n], outDegree[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        inDegree[i] = <span class="number">0</span>;</span><br><span class="line">        outDegree[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g[i].<span class="built_in">size</span>(); j++) {</span><br><span class="line">            outDegree[i]++;</span><br><span class="line">            inDegree[g[i][j]]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断根节点数量和索引</span></span><br><span class="line">    <span class="type">int</span> rootIndex = <span class="number">-1</span>, rootCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) {</span><br><span class="line">            rootCnt++;</span><br><span class="line">            rootIndex = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (rootCnt != <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从根节点遍历是否能遍历到所有节点</span></span><br><span class="line">    <span class="type">bool</span> st[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        st[i] = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(g, rootIndex, st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断出入度是否满足条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (outDegree[i] &gt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i == rootIndex) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] != <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBinaryTree</span><span class="params">(<span class="type">int</span> n, List&lt;Integer[]&gt; edges)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            g.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (Integer[] e : edges) {</span><br><span class="line">            g.get(e[<span class="number">0</span>]).add(e[<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] outDegree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(inDegree, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(outDegree, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : g.get(i)) {</span><br><span class="line">                outDegree[i]++;</span><br><span class="line">                inDegree[j]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> -<span class="number">1</span>, rootCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) {</span><br><span class="line">                rootCnt++;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (rootCnt != <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">boolean</span>[] st = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        dfs(g, rootIndex, st);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!st[i]) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (outDegree[i] &gt; <span class="number">2</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i == rootIndex) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] != <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; g, <span class="type">int</span> t, <span class="type">boolean</span>[] st)</span> {</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : g.get(t)) {</span><br><span class="line">            <span class="keyword">if</span> (!st[j]) {</span><br><span class="line">                dfs(g, j, st);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="图">4 图</h1>
<h2 id="图的存储">4.1 图的存储</h2>
<p>这种方式，对于很多算法都很方便，难点在于给定一个图结构，首先需要把给定的图结构转换成该图结构。对于某些算法用不到某些数据，如
入度in和出度out可以不写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> {</span><br><span class="line">    <span class="comment">// 如果知道确切的顶点个数，可以使用数组代替HashMap</span></span><br><span class="line">	<span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">	<span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">()</span> {</span><br><span class="line">		nodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		edges = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点结构的描述</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> in;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> out;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		out = <span class="number">0</span>;</span><br><span class="line">		nexts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">	<span class="keyword">public</span> Node from;</span><br><span class="line">	<span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> weight, Node from, Node to)</span> {</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">		<span class="built_in">this</span>.from = from;</span><br><span class="line">		<span class="built_in">this</span>.to = to;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// matrix 所有的边</span></span><br><span class="line"><span class="comment">// N*3 的矩阵</span></span><br><span class="line"><span class="comment">// [weight, from节点上面的值，to节点上面的值]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// [ 5 , 0 , 7]</span></span><br><span class="line"><span class="comment">// [ 3 , 0,  1]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title function_">createGraph</span><span class="params">(<span class="type">int</span>[][] matrix)</span> {</span><br><span class="line">	<span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) {</span><br><span class="line">		 <span class="comment">// 拿到每一条边， matrix[i] </span></span><br><span class="line">		<span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> matrix[i][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> matrix[i][<span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> matrix[i][<span class="number">2</span>];</span><br><span class="line">        graph.nodes.putIfAbsent(from, <span class="keyword">new</span> <span class="title class_">Node</span>(from));</span><br><span class="line">		<span class="comment">// if (!graph.nodes.containsKey(from)) {</span></span><br><span class="line">		<span class="comment">// 	graph.nodes.put(from, new Node(from));</span></span><br><span class="line">		<span class="comment">// }</span></span><br><span class="line">        graph.nodes.putIfAbsent(to, <span class="keyword">new</span> <span class="title class_">Node</span>(to));</span><br><span class="line">		<span class="comment">// if (!graph.nodes.containsKey(to)) {</span></span><br><span class="line">		<span class="comment">// 	graph.nodes.put(to, new Node(to));</span></span><br><span class="line">		<span class="comment">// }</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">fromNode</span> <span class="operator">=</span> graph.nodes.get(from);</span><br><span class="line">		<span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> graph.nodes.get(to);</span><br><span class="line">		<span class="comment">// 无向图可以看作是两条边的有向图</span></span><br><span class="line">        <span class="comment">// 第一条边</span></span><br><span class="line">        <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(weight, fromNode, toNode);</span><br><span class="line">        fromNode.nextNodes.add(toNode);</span><br><span class="line">        fromNode.edges.add(edge);</span><br><span class="line">        fromNode.out++;</span><br><span class="line">        toNode.in++;</span><br><span class="line">        graph.edges.add(edge);</span><br><span class="line">        <span class="comment">// 第二条边</span></span><br><span class="line">        edge = <span class="keyword">new</span> <span class="title class_">Edge</span>(weight, toNode, fromNode);</span><br><span class="line">        toNode.nextNodes.add(fromNode);</span><br><span class="line">        toNode.edges.add(edge);</span><br><span class="line">        toNode.out++;</span><br><span class="line">        fromNode.in++;</span><br><span class="line">        graph.edges.add(edge);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> graph;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这个版本代码量少，易于理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储每个顶点的信息和该顶点所有边的信息。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Edge&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 存储每条边的信息（也可以用链表表示，用链表Node中的边只需用头节点存储即可）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> {</span><br><span class="line">    <span class="type">int</span> n, w;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> weight)</span> {</span><br><span class="line">        n = node;</span><br><span class="line">        w = weight;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node[] createGraph(<span class="type">int</span>[][] matrix, <span class="type">int</span> n) {</span><br><span class="line">    Node[] graph = <span class="keyword">new</span> <span class="title class_">Node</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> matrix[i][<span class="number">0</span>], from = matrix[i][<span class="number">1</span>], to = matrix[i][<span class="number">2</span>];</span><br><span class="line">        graph[from].edges.add(<span class="keyword">new</span> <span class="title class_">Edge</span>(to, weight));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>c++版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义边数据结构，存储边到达的下一个顶点和权重</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> { <span class="type">int</span> n, w; };</span><br><span class="line"><span class="comment">// 邻接表表示图，可以用两个vector表示，也可以用一个存储vector的数组表示</span></span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line"><span class="comment">// vector&lt;Edge&gt; g[n];</span></span><br></pre></td></tr></table></figure>
<h2 id="宽度优先遍历">4.2 宽度优先遍历</h2>
<p>如下所示的图：<br><img src="https://cdn.nlark.com/yuque/__mermaid_v3/c57a0c0d1f9ab4725fe2419b34ca74af.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBMUlxuMCAtLTItLT4gMVxuMSAtLTItLT4gMlxuMCAtLTEtLT4gMlxuMiAtLTItLT4gM1xuMSAtLTUtLT4gM1xuMCAtLTQtLT4gNFxuMyAtLTctLT4gNCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvYzU3YTBjMGQxZjlhYjQ3MjVmZTI0MTliMzRjYTc0YWYuc3ZnIiwiaWQiOiJlUTRRUCIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=#id=G1fJ5&amp;originHeight=194&amp;originWidth=381&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Graph graph)</span> {</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用于判断顶点是否访问过</span></span><br><span class="line">    Set&lt;Node&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 随便选一个顶点作为开始顶点</span></span><br><span class="line">    visited.add(graph.nodes.get(<span class="number">0</span>));</span><br><span class="line">    queue.add(graph.nodes.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">        <span class="keyword">for</span> (Node nextNode : node.nextNodes) {</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(nextNode)) {</span><br><span class="line">                visited.add(nextNode);</span><br><span class="line">                queue.add(nextNode);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="深度优先遍历">4.3 深度优先遍历</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Graph graph)</span> {</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> graph.nodes.get(<span class="number">0</span>);</span><br><span class="line">    Set&lt;Node&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    visited.add(node);</span><br><span class="line">    recur(node, visited);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(Node node, Set&lt;Node&gt; visited)</span> {</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    <span class="keyword">for</span> (Node nextNode : node.nextNodes) {</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(nextNode)) {</span><br><span class="line">            visited.add(nextNode);</span><br><span class="line">            recur(nextNode, visited);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序">4.4 拓扑排序</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/description/">课表排序<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> {</span><br><span class="line">        Node[] g = <span class="keyword">new</span> <span class="title class_">Node</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">            g[i] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] prereq : prerequisites) {</span><br><span class="line">            g[prereq[<span class="number">1</span>]].edges.add(prereq[<span class="number">0</span>]);</span><br><span class="line">            in[prereq[<span class="number">0</span>]]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; in.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>) {</span><br><span class="line">                queue.add(i);</span><br><span class="line">                cnt++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n : g[node].edges) {</span><br><span class="line">                in[n]--;</span><br><span class="line">                <span class="keyword">if</span> (in[n] == <span class="number">0</span>) {</span><br><span class="line">                    queue.add(n);</span><br><span class="line">                    cnt++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cnt == numCourses;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 边只表示下一个顶点即可，因此不需要单独创建边类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">    List&lt;Integer&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// directed graph and no loop</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">sortedTopology</span><span class="params">(Graph graph)</span> {</span><br><span class="line">    <span class="comment">// key 某个节点   value 剩余的入度</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 只有剩余入度为0的点，才进入这个队列</span></span><br><span class="line">    Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) {</span><br><span class="line">        inMap.put(node, node.in);</span><br><span class="line">        <span class="keyword">if</span> (node.in == <span class="number">0</span>) {</span><br><span class="line">            zeroInQueue.add(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    List&lt;Node&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!zeroInQueue.isEmpty()) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> zeroInQueue.poll();</span><br><span class="line">        result.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) {</span><br><span class="line">            inMap.put(next, inMap.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>) {</span><br><span class="line">                zeroInQueue.add(next);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="kruskal算法">4.5 Kruskal算法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储每个顶点的父顶点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Integer&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 查询顶点x的父顶点，同时在查询过程中修改结构使得提高查询速度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parent.get(x) != x) {</span><br><span class="line">        parent.put(x, find(parent.get(x)));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> parent.get(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">(Graph graph)</span> {</span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) {</span><br><span class="line">        parent.put(node.value, node.value);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 优先队列保证每次取出的是最小值</span></span><br><span class="line">    Queue&lt;Edge&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.weight - o2.weight);</span><br><span class="line">    queue.addAll(graph.edges);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> find(edge.from.value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> find(edge.to.value);</span><br><span class="line">        <span class="comment">// 如果两个顶点的父顶点不同，说明连接起来不会形成环</span></span><br><span class="line">        <span class="keyword">if</span> (from != to) {</span><br><span class="line">            parent.put(from, to);</span><br><span class="line">            System.out.println(edge.from.value + <span class="string">" "</span> + edge.to.value + <span class="string">" "</span> + edge.weight);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="prim算法">4.6 Prim算法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prim</span><span class="params">(Graph graph)</span> {</span><br><span class="line">    Queue&lt;Edge&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Node&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// for循环用于处理图不连通的情况</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) {</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(node)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 找一个node顶点开始</span></span><br><span class="line">        visited.add(node);</span><br><span class="line">        <span class="comment">// 加入node的所有边</span></span><br><span class="line">        queue.addAll(node.edges);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="comment">// 选出解锁的边的最小的边判断</span></span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">to</span> <span class="operator">=</span> edge.to;</span><br><span class="line">            <span class="comment">// 如果这个边的另一个顶点没有加入，则加入到结果中，同时把新加入的顶点的所有边（新解锁的边）加入到堆中</span></span><br><span class="line">            <span class="keyword">if</span> (visited.contains(to)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果该顶点是新顶点，则这个边也可以加入到最小生成树的边中</span></span><br><span class="line">            visited.add(to);</span><br><span class="line">            System.out.println(edge.from.value + <span class="string">" "</span> + edge.to.value + <span class="string">" "</span> + edge.weight);</span><br><span class="line">            queue.addAll(to.edges);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="前缀trie树">4.7 前缀Trie树</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">trie前缀树<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Trie[] next = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> {</span><br><span class="line">        <span class="keyword">if</span> (search(word)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : words) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.next[index] == <span class="literal">null</span>) {</span><br><span class="line">                cur.next[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            }</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        }</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> {</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : words) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.next[index] == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur.isEnd;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> {</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">char</span>[] words = prefix.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : words) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.next[index] == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;Trie*&gt; next;</span><br><span class="line">    <span class="type">bool</span> is_end;</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">next</span>(<span class="number">26</span>), <span class="built_in">is_end</span>(<span class="literal">false</span>) {}</span><br><span class="line">    <span class="comment">// c++需要手动释放内存，因为next数组中的指针是new出来的，否则会造成内存泄漏</span></span><br><span class="line">    <span class="comment">// 虽然算法题是一次运行，基本不会出现内存泄漏，但是在笔试面试中尽可能完善，所以需要手动释放</span></span><br><span class="line">    ~<span class="built_in">Trie</span>() {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : next) {</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">search</span>(word)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Trie *cur = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word) {</span><br><span class="line">            <span class="type">int</span> index = ch - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next[index] == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="comment">// 这里进行了new操作申请了空间，需要在析构函数中释放掉</span></span><br><span class="line">                cur-&gt;next[index] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            }</span><br><span class="line">            cur = cur-&gt;next[index];</span><br><span class="line">        }</span><br><span class="line">        cur-&gt;is_end = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>{</span><br><span class="line">        Trie *cur = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : word) {</span><br><span class="line">            <span class="type">int</span> index = ch - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next[index] == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            cur = cur-&gt;next[index];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;is_end;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>{</span><br><span class="line">        Trie *cur = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : prefix) {</span><br><span class="line">            <span class="type">int</span> index = ch - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next[index] == <span class="literal">nullptr</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            cur = cur-&gt;next[index];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_Trie</span> {</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试链接 : https://leetcode.cn/problems/implement-trie-ii-prefix-tree/</span></span><br><span class="line">	<span class="comment">// 提交Trie类可以直接通过</span></span><br><span class="line">	<span class="comment">// 原来代码是对的，但是既然找到了直接测试的链接，那就直接测吧</span></span><br><span class="line">	<span class="comment">// 这个链接上要求实现的功能和课上讲的完全一样</span></span><br><span class="line">	<span class="comment">// 该前缀树的路用数组实现</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Trie</span> {</span><br><span class="line"></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> pass;</span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line">			<span class="keyword">public</span> Node[] nexts;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> {</span><br><span class="line">				pass = <span class="number">0</span>;</span><br><span class="line">				end = <span class="number">0</span>;</span><br><span class="line">				nexts = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> {</span><br><span class="line">			root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> {</span><br><span class="line">			<span class="keyword">if</span> (word == <span class="literal">null</span>) {</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="type">char</span>[] str = word.toCharArray();</span><br><span class="line">			<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">			node.pass++;</span><br><span class="line">			<span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) { <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">				path = str[i] - <span class="string">'a'</span>; <span class="comment">// 由字符，对应成走向哪条路</span></span><br><span class="line">				<span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) {</span><br><span class="line">					node.nexts[path] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">				}</span><br><span class="line">				node = node.nexts[path];</span><br><span class="line">				node.pass++;</span><br><span class="line">			}</span><br><span class="line">			node.end++;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(String word)</span> {</span><br><span class="line">			<span class="keyword">if</span> (countWordsEqualTo(word) != <span class="number">0</span>) {</span><br><span class="line">				<span class="type">char</span>[] chs = word.toCharArray();</span><br><span class="line">				<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">				node.pass--;</span><br><span class="line">				<span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) {</span><br><span class="line">					path = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">					<span class="keyword">if</span> (--node.nexts[path].pass == <span class="number">0</span>) {</span><br><span class="line">						node.nexts[path] = <span class="literal">null</span>;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					}</span><br><span class="line">					node = node.nexts[path];</span><br><span class="line">				}</span><br><span class="line">				node.end--;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String word)</span> {</span><br><span class="line">			<span class="keyword">if</span> (word == <span class="literal">null</span>) {</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="type">char</span>[] chs = word.toCharArray();</span><br><span class="line">			<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) {</span><br><span class="line">				index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">				<span class="keyword">if</span> (node.nexts[index] == <span class="literal">null</span>) {</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				}</span><br><span class="line">				node = node.nexts[index];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> node.end;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String pre)</span> {</span><br><span class="line">			<span class="keyword">if</span> (pre == <span class="literal">null</span>) {</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="type">char</span>[] chs = pre.toCharArray();</span><br><span class="line">			<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) {</span><br><span class="line">				index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">				<span class="keyword">if</span> (node.nexts[index] == <span class="literal">null</span>) {</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				}</span><br><span class="line">				node = node.nexts[index];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> node.pass;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="迪杰斯特拉算法">4.8 迪杰斯特拉算法</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/network-delay-time/description/">网络延迟时间<i class="fas fa-external-link-alt"></i></a></p>
<ol type="1">
<li>普通算法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Node, Integer&gt; <span class="title function_">dijkstra</span><span class="params">(Graph graph)</span> {</span><br><span class="line">    <span class="comment">// 保存起始顶点到每个顶点的距离，如果没有则认为距离为正无穷</span></span><br><span class="line">    Map&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置0为起始顶点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> graph.nodes.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 起始顶点到自己的距离为0</span></span><br><span class="line">    distanceMap.put(minNode, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 保存哪些顶点加入到判断完的集合中（距离已经是最短的）</span></span><br><span class="line">    Set&lt;Node&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (minNode != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">distance</span> <span class="operator">=</span> distanceMap.get(minNode);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : minNode.edges) {</span><br><span class="line">            <span class="comment">// 如果不存在则表示起始顶点到edge.to顶点距离为正无穷，直接添加</span></span><br><span class="line">            <span class="comment">// 如果存在则需要判断  起始顶点直接到edge.to顶点的距离  和</span></span><br><span class="line">            <span class="comment">// 起始顶点到minNode顶点加上minNode到edge.to的距离哪个更小</span></span><br><span class="line">            <span class="keyword">if</span> (!distanceMap.containsKey(edge.to)) {</span><br><span class="line">                distanceMap.put(edge.to, distance + edge.weight);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                distanceMap.put(edge.to, Math.min(distance + edge.weight, distanceMap.get(edge.to)));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 更新结束，将minNode加入集合中</span></span><br><span class="line">        visited.add(minNode);</span><br><span class="line">        <span class="comment">// minNode置为null，(重要)，后续循环退出条件是通过判断minNode是否为空</span></span><br><span class="line">        minNode = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 保存最小距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minDist</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 遍历所有的距离，在没有判断确定的顶点中选择距离最短的</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">dist</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="comment">// 如果已经是判断过的顶点则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(node) &amp;&amp; minDist &gt; dist) {</span><br><span class="line">                minDist = dist;</span><br><span class="line">                minNode = node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> distanceMap;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>另一种方式（推荐），图存储方式简单些</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        Node[] g = <span class="keyword">new</span> <span class="title class_">Node</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            g[i] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] time : times) {</span><br><span class="line">            g[time[<span class="number">0</span>] - <span class="number">1</span>].edges.add(<span class="keyword">new</span> <span class="title class_">Edge</span>(time[<span class="number">1</span>] - <span class="number">1</span>, time[<span class="number">2</span>]));</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        <span class="type">boolean</span>[] st = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        dist[k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (!st[j] &amp;&amp; (t == -<span class="number">1</span> || dist[t] &gt; dist[j])) {</span><br><span class="line">                    t = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : g[t].edges) {</span><br><span class="line">                dist[edge.n] = Math.min(dist[edge.n], dist[t] + edge.w);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDist</span> <span class="operator">=</span> Arrays.stream(dist).max().getAsInt();</span><br><span class="line">        <span class="keyword">return</span> maxDist == <span class="number">0x3f3f3f3f</span> ? -<span class="number">1</span> : maxDist;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> {</span><br><span class="line">    <span class="type">int</span> n, w;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> weight)</span> {</span><br><span class="line">        n = node;</span><br><span class="line">        w = weight;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">    List&lt;Edge&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>another <code>cpp</code>版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> {</span><br><span class="line">        <span class="type">int</span> n, w;</span><br><span class="line">    };</span><br><span class="line">    <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">networkDelayTime</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; times, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="comment">// 两个vector表示邻接表</span></span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;Edge&gt;&gt; g(n);</span></span><br><span class="line">        <span class="comment">// 或者vector&lt;Edge&gt;数组表示邻接表</span></span><br><span class="line">        vector&lt;Edge&gt; g[n];</span><br><span class="line">        <span class="comment">// foreach循环使用引用提高速度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;time : times) {</span><br><span class="line">            g[time[<span class="number">0</span>] - <span class="number">1</span>].<span class="built_in">push_back</span>({time[<span class="number">1</span>] - <span class="number">1</span>, time[<span class="number">2</span>]});</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> dist[n];</span><br><span class="line">        <span class="type">bool</span> st[n];</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        dist[k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) {</span><br><span class="line">                    t = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : g[t]) {</span><br><span class="line">                dist[edge.n] = <span class="built_in">min</span>(dist[edge.n], dist[t] + edge.w);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> maxDist = *<span class="built_in">max_element</span>(dist, dist + n);</span><br><span class="line">        <span class="keyword">return</span> maxDist == INF ? <span class="number">-1</span> : maxDist;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>优化算法</li>
</ol>
<h1 id="贪心算法">5 贪心算法</h1>
<h2 id="会议安排">5.1 会议安排</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-pair-chain/description/">LeetCode
646<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLongestChain</span><span class="params">(<span class="type">int</span>[][] pairs)</span> {</span><br><span class="line">        Arrays.sort(pairs, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">retLength</span> <span class="operator">=</span> <span class="number">0</span>, curTime = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] pair : pairs) {</span><br><span class="line">            <span class="keyword">if</span> (curTime &lt; pair[<span class="number">0</span>]) {</span><br><span class="line">                retLength++;</span><br><span class="line">                curTime = pair[<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> retLength;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/10356726/1714318151641-e14a1fe8-5428-4745-86f6-6f1e36d3dcbe.png#averageHue=%23dbdbdb&amp;clientId=u9d240ba5-f15b-4&amp;from=paste&amp;height=136&amp;id=u1d683546&amp;originHeight=170&amp;originWidth=1154&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=156006&amp;status=done&amp;style=none&amp;taskId=u70cf751a-9d3e-40e2-8807-8b9559fbd88&amp;title=&amp;width=923.2#averageHue=%23dbdbdb&amp;id=e4LAf&amp;originHeight=170&amp;originWidth=1154&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Program</span> {</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxMeetings</span><span class="params">(Program[] programs)</span> {</span><br><span class="line">    <span class="comment">// 按照结束时间排序</span></span><br><span class="line">    Arrays.sort(programs, (p1, p2) -&gt; p1.end - p2.end);</span><br><span class="line">    <span class="type">int</span> <span class="variable">timePoint</span> <span class="operator">=</span> programs[<span class="number">0</span>].start;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; programs.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (timePoint &lt;= programs[i].start) {</span><br><span class="line">            timePoint = programs[i].end;</span><br><span class="line">            ret++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="字符串数组排序">5.2 字符串数组排序</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortString</span><span class="params">(String[] strs)</span> {</span><br><span class="line">    <span class="comment">// 按照两个字符串不同拼接方式排序</span></span><br><span class="line">    Arrays.sort(strs, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="金条划分">5.3 金条划分</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/10356726/1714443646239-6e9ca0e0-d29f-4162-8ddc-fd9c12dac79f.png#averageHue=%23dfdedf&amp;clientId=u3272c77d-2f5c-4&amp;from=paste&amp;height=312&amp;id=ua8db6952&amp;originHeight=390&amp;originWidth=1151&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=418298&amp;status=done&amp;style=none&amp;taskId=ua8745034-2445-4682-b7b0-1435058bfb1&amp;title=&amp;width=920.8#averageHue=%23dfdedf&amp;id=FWRL1&amp;originHeight=390&amp;originWidth=1151&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<p><img src="https://cdn.nlark.com/yuque/__mermaid_v3/89ac03b414d4b059564265ac4eeb89ed.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBURFxuYSgoNjApKSAtLT4gYigoMTApKVxuYSAtLT4gYygoNTApKVxuYyAtLT4gZCgoMjApKVxuYyAtLT4gZSgoMzApKVxuXG5zdHlsZSBiIGZpbGw6IHBpbmtcbnN0eWxlIGQgZmlsbDogcGlua1xuc3R5bGUgZSBmaWxsOiBwaW5rXG5cbmExKCg2MCkpIC0tPiBiMSgoMzApKVxuYTEgLS0-IGMxKCgzMCkpXG5jMSAtLT4gZDEoKDEwKSlcbmMxIC0tPiBlMSgoMjApKVxuXG5zdHlsZSBiMSBmaWxsOiBwaW5rXG5zdHlsZSBkMSBmaWxsOiBwaW5rXG5zdHlsZSBlMSBmaWxsOiBwaW5rIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fbWVybWFpZF92My84OWFjMDNiNDE0ZDRiMDU5NTY0MjY1YWM0ZWViODllZC5zdmciLCJpZCI6IlJ6YU9JIiwibWFyZ2luIjp7InRvcCI6dHJ1ZSwiYm90dG9tIjp0cnVlfSwiY2FyZCI6ImRpYWdyYW0ifQ==#id=SVwEO&amp;originHeight=221&amp;originWidth=349&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<p>按照上图中的两个不同分割法：</p>
<ul>
<li>第一种：先划分为10和50，消耗60，再划分为20和30，消耗50，总计110。</li>
<li>第二种：先划分为30和30，消耗60，再划分为10和20，消耗30，总计90。</li>
</ul>
<p>如果要取到最小的，需要先按照最大的划分，逆向过来，这是一颗哈夫曼树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lessMoney</span><span class="params">(<span class="type">int</span>[] arr)</span> {</span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a : arr) {</span><br><span class="line">        heap.add(a);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.size() &gt; <span class="number">1</span>) {</span><br><span class="line">        cur = heap.remove() + heap.remove();</span><br><span class="line">        sum += cur;</span><br><span class="line">        heap.add(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="利润最大">5.4 利润最大</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/ipo/description/">LeetCode
502<i class="fas fa-external-link-alt"></i></a></p>
<p>先按照<code>成本花费</code>升序排序，每一轮选出可以做的（成本不大于当前资金的）项目，加入到另一个集合中保存，选出利润最大的做，然后更新当前可用资金。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, <span class="type">int</span>[] profits, <span class="type">int</span>[] capital)</span> {</span><br><span class="line">        Queue&lt;Pair&gt; capHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((p1, p2) -&gt; p1.c - p2.c);</span><br><span class="line">        Queue&lt;Pair&gt; proHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((p1, p2) -&gt; p2.p - p1.p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; profits.length; i++) {</span><br><span class="line">            capHeap.add(<span class="keyword">new</span> <span class="title class_">Pair</span>(profits[i], capital[i]));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">            <span class="keyword">while</span> (!capHeap.isEmpty() &amp;&amp; capHeap.peek().c &lt;= w) {</span><br><span class="line">                proHeap.add(capHeap.remove());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (proHeap.isEmpty()) {</span><br><span class="line">                <span class="keyword">return</span> w;</span><br><span class="line">            }</span><br><span class="line">            w += proHeap.remove().p;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> {</span><br><span class="line">    <span class="type">int</span> p, c;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> c)</span> {</span><br><span class="line">        <span class="built_in">this</span>.p = p;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="数据流的中位数堆的应用">5.5 数据流的中位数(堆的应用)</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/description/">LeetCode
295<i class="fas fa-external-link-alt"></i></a></p>
<p>用两个堆，一个大根堆一个小根堆，其中大根堆保存小于等于中位数部分的数据，小根堆保存大于中位数部分的数据。</p>
<p>插入数据算法流程：</p>
<ol type="1">
<li>如果大根堆空，直接加入大根堆，结束，否则执行2</li>
<li>如果小于等于大根堆堆顶，加入大根堆，否则加入小根堆</li>
<li>判断大小根堆数据量差值，如果插值大于1，则将数据量多的堆的堆顶弹出加入到另一个堆中</li>
</ol>
<p>查询算法流程：</p>
<ol type="1">
<li>如果两个堆数据量相同，则大小根堆查询堆顶相加除以2，得到中位数，结束，否则执行2</li>
<li>返回数据量大的堆的堆顶元素</li>
</ol>
<figure>
<img src="https://cdn.nlark.com/yuque/0/2024/svg/10356726/1716612103763-23720eb1-ff62-4eb8-a5e2-852517c07a29.svg#clientId=u157bfddc-d94f-4&amp;from=paste&amp;height=635&amp;id=ue41d177f&amp;originHeight=794&amp;originWidth=890&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=263722&amp;status=done&amp;style=none&amp;taskId=u7b02a101-048a-4464-a4ae-8f8288305d1&amp;title=&amp;width=712" alt="5.5-1.drawio.svg">
<figcaption aria-hidden="true">5.5-1.drawio.svg</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty()) {</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= maxHeap.peek()) {</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() - minHeap.size() &gt; <span class="number">1</span>) {</span><br><span class="line">            minHeap.add(maxHeap.remove());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (minHeap.size() - maxHeap.size() &gt; <span class="number">1</span>) {</span><br><span class="line">            maxHeap.add(minHeap.remove());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size()) {</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &gt; minHeap.size()) {</span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="暴力递归">6 暴力递归</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences-ii/description/">LeetCode
940<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="字符串全排列">6.1 字符串全排列</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">LeetCode
46<i class="fas fa-external-link-alt"></i></a></p>
<ol type="1">
<li>不去重</li>
<li>去重</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">permutation3</span><span class="params">(String s)</span> {</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">    g2(str, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g2</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> index, List&lt;String&gt; ans)</span> {</span><br><span class="line">    <span class="keyword">if</span> (index == str.length) {</span><br><span class="line">        ans.add(String.valueOf(str));</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; str.length; i++) {</span><br><span class="line">            <span class="comment">// 不去重删除掉这个if判断代码即可</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[str[i]]) {</span><br><span class="line">                visited[str[i]] = <span class="literal">true</span>;</span><br><span class="line">                swap(str, index, i);</span><br><span class="line">                g2(str, index + <span class="number">1</span>, ans);</span><br><span class="line">                swap(str, index, i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="预测赢家">6.2 预测赢家</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/predict-the-winner/description/">LeetCode
486<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">predictTheWinner</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == j) {</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums[i] - dfs(nums, i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums[j] - dfs(nums, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>可以设置两个函数，分别为先手和后手函数。记为<code>f(arr, l, r)</code>和<code>s(arr, l, r)</code>分别表示在<code>arr</code>中的<code>l</code>和<code>r</code>范围内进行决策得到的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(arr, l, r)</span> {</span><br><span class="line">    <span class="comment">// 如果只有一个数，那么先手只能拿这一个</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) {</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 否则有两种决策情况，一种是拿最左侧，一种是拿最右侧</span></span><br><span class="line">    <span class="comment">// 而拿完后，剩下的数对于当前来说属于后手，所以调用后手函数，而为了保证当前分数为最大值，所以使用max取最大值</span></span><br><span class="line">    <span class="keyword">return</span> max(arr[l] + s(arr, l + <span class="number">1</span>, r), arr[r] + s(arr, l, r - <span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">s</span><span class="params">(arr, l, r)</span> {</span><br><span class="line">    <span class="comment">// 如果为后手，只有一个数，那么先手会拿到这个数，后手没得拿只能返回0</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 后手拿[l, r]范围内的数，只有两种可能，因为先手只能拿最左侧或最右侧。</span></span><br><span class="line">    <span class="comment">// 先手拿完后，后手变成了先手，所以调用先手函数。</span></span><br><span class="line">    <span class="comment">// 而同时两个人都保证分数最大化，所以先手拿完后肯定要保证后手是分数最小化，所以需要取最小值。</span></span><br><span class="line">    <span class="keyword">return</span> min(f(arr, l + <span class="number">1</span>, r), f(arr, l, r - <span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/">1423.
可获得的最大点数 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="解码方法">6.3 解码方法</h2>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/description/">LeetCode
91<i class="fas fa-external-link-alt"></i></a></p>
<p>递归方法（会超时）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="keyword">return</span> numDecodings(s.toCharArray(), <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == chs.length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (chs[i] == <span class="string">'0'</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> numDecodings(chs, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (chs[i] == <span class="string">'1'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; chs.length) {</span><br><span class="line">                ret += numDecodings(chs, i + <span class="number">2</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (chs[i] == <span class="string">'2'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; chs.length &amp;&amp; chs[i + <span class="number">1</span>] &lt; <span class="string">'7'</span>) {</span><br><span class="line">                ret += numDecodings(chs, i + <span class="number">2</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="n皇后问题">6.4 n皇后问题</h2>
<p>常规方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前来到i行，一共是0~N-1行</span></span><br><span class="line"><span class="comment">// 在i行上放皇后，所有列都尝试</span></span><br><span class="line"><span class="comment">// 必须要保证跟之前所有的皇后不打架</span></span><br><span class="line"><span class="comment">// int[] record record[x] = y 之前的第x行的皇后，放在了y列上</span></span><br><span class="line"><span class="comment">// 返回：不关心i以上发生了什么，i.... 后续有多少合法的方法数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] record, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i == n) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// i行的皇后，放哪一列呢？j列，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">        <span class="keyword">if</span> (isValid(record, i, j)) {</span><br><span class="line">            record[i] = j;</span><br><span class="line">            res += process1(i + <span class="number">1</span>, record, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span>[] record, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="comment">// 0..i-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++) {</span><br><span class="line">        <span class="comment">// 判断是不是在同一列或者是在同一斜线上，此处用斜率判断，1或者-1</span></span><br><span class="line">        <span class="keyword">if</span> (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请不要超过32皇后问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num2</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果你是13皇后问题，limit 最右13个1，其他都是0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> n == <span class="number">32</span> ? -<span class="number">1</span> : (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> process2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7皇后问题</span></span><br><span class="line"><span class="comment">// limit : 0....0 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">// 之前皇后的列影响：colLim</span></span><br><span class="line"><span class="comment">// 之前皇后的左下对角线影响：leftDiaLim</span></span><br><span class="line"><span class="comment">// 之前皇后的右下对角线影响：rightDiaLim</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span> limit, <span class="type">int</span> colLim, <span class="type">int</span> leftDiaLim, <span class="type">int</span> rightDiaLim)</span> {</span><br><span class="line">    <span class="keyword">if</span> (colLim == limit) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// pos中所有是1的位置，是你可以去尝试皇后的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">    <span class="type">int</span> <span class="variable">mostRightOne</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos != <span class="number">0</span>) {</span><br><span class="line">        mostRightOne = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line">        pos = pos - mostRightOne;</span><br><span class="line">        res += process2(limit, colLim | mostRightOne, (leftDiaLim | mostRightOne) &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                        (rightDiaLim | mostRightOne) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>打印所有可能的n皇后解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[][] g;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] record;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        g = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        record = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(record, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            Arrays.fill(g[i], <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line">        recur(<span class="number">0</span>, n);</span><br><span class="line">        sc.close();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == n) {</span><br><span class="line">            <span class="comment">// 清空sb内容。</span></span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                    sb.append(g[k][j]);</span><br><span class="line">                }</span><br><span class="line">                sb.append(<span class="string">'\n'</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (isValid(i, j)) {</span><br><span class="line">                    record[i] = j;</span><br><span class="line">                    g[i][j] = <span class="string">'Q'</span>;</span><br><span class="line">                    recur(i + <span class="number">1</span>, n);</span><br><span class="line">                    g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                    record[i] = -<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="comment">// (i, j) (k, record[k])</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++) {</span><br><span class="line">            <span class="keyword">if</span> (j == record[k] || Math.abs(i - k) == Math.abs(j - record[k])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后 -
力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[][] g = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(record, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            Arrays.fill(g[i], <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>, n, g, record, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">char</span>[][] g, <span class="type">int</span>[] record, List&lt;List&lt;String&gt;&gt; ret)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == n) {</span><br><span class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                temp.add(String.valueOf(g[j]));</span><br><span class="line">            }</span><br><span class="line">            ret.add(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (isValid(i, j, record)) {</span><br><span class="line">                record[i] = j;</span><br><span class="line">                g[i][j] = <span class="string">'Q'</span>;</span><br><span class="line">                dfs(i + <span class="number">1</span>, n, g, record, ret);</span><br><span class="line">                g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                record[i] = -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] record)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++) {</span><br><span class="line">            <span class="keyword">if</span> (j == record[k] || Math.abs(i - k) == Math.abs(j - record[k])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="哈希函数与哈希表">7 哈希函数与哈希表</h1>
<p>哈希函数的性质（简要记录）：</p>
<ol type="1">
<li>无穷多的值映射到有范围的值</li>
<li>相同的输入得到相同的输出</li>
<li>不同的输入可能得到相同的输出</li>
<li>映射后的值分布比较均匀</li>
</ol>
<h2 id="例题">7.1 例题</h2>
<p>题目：如果有一个40亿条记录的大文件，现需要求出现次数最多的记录，限制内存使用为1GB。<br>解法：如果直接采用哈希表的方式按照（记录，次数）的方式存储每个记录的次数，内存肯定会不够。因此采用哈希函数首先将记录做一次哈希，然后将得到的值模100，最后肯定会得到一个0-99的值，按照模除后的结果将该条记录存到对应的小文件中，再对每个小文件使用哈希表的方式进行统计（此时的内存空间是够用的）。<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/10356726/1719818511337-d1e0a1a1-7ac2-42c1-bc0b-95c7e3e68b55.jpeg"><br>❗如果采用<strong>摩尔投票法</strong>需要保证重复的记录超过总记录数的一半。</p>
<h2 id="布隆过滤器">7.2 布隆过滤器</h2>
<p>主要用于类似<strong>黑名单系统</strong>，查找当前记录是否存在于“黑名单”中，并且这个黑名单只会添加记录，不会删除记录，使用布隆过滤器可以比使用hash表大大减少空间。但是布隆过滤器存在一定的失误率，即不存在于黑名单的记录可能也会认为是黑名单，可以通过设置大小大大降低失误率，但是失误率是一直存在的。<br>使用到的数据结构：二进制位组成的集合。<br><strong>算法过程：</strong></p>
<ol type="1">
<li>准备<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container></span>个哈希函数<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="12.359ex" height="2.059ex" role="img" focusable="false" viewBox="0 -705 5462.5 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(926.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1371.2,0)"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2297.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(2742.4,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(3187.1,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(3631.8,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(4076.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(4521.1,0)"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g></svg></mjx-container></span></li>
<li>添加黑名单
<ol type="1">
<li>遍历黑名单记录列表
<ol type="1">
<li>遍历哈希函数
<ol type="1">
<li>每个哈希函数求得一个哈希值<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span></li>
<li>将位集合中的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>位设置为1</li>
</ol></li>
</ol></li>
</ol></li>
<li>判断是否在黑名单中
<ol type="1">
<li>对于一个记录遍历哈希函数
<ol type="1">
<li>求得一个哈希值<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span></li>
<li>判断是否为1</li>
</ol></li>
<li>当所有的位置都为1时说明在黑名单中（可能存在失误），否则不在</li>
</ol></li>
</ol>
<p>首先需要构造一个二进制位集合，这里可以采用<code>int</code>数组的形式，每一个值表示32位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设总共需要m位的集合</span></span><br><span class="line"><span class="comment">// 上取整</span></span><br><span class="line"><span class="type">int</span> a[<span class="built_in">ceil</span>(m / <span class="number">32</span>)];</span><br><span class="line"><span class="comment">// 将第i位设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setI1</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> i)</span> </span>{</span><br><span class="line">    <span class="type">int</span> index = i / <span class="number">32</span>, bit_index = i % <span class="number">32</span>;</span><br><span class="line">    a[index] = a[index] | (<span class="number">1</span> &lt;&lt; bit_index);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 将第i位设置为0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setI0</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> i)</span> </span>{</span><br><span class="line">    <span class="type">int</span> index = i / <span class="number">32</span>, bit_index = i % <span class="number">32</span>;</span><br><span class="line">    a[index] = a[index] &amp; (~(<span class="number">1</span> &lt;&lt; bit_index))</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 获取第i位的值（0或1）</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">getI</span>(<span class="type">int</span> *a, <span class="type">int</span> i) {</span><br><span class="line">    <span class="type">int</span> index = i / <span class="number">32</span>, bit_index = i % <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">return</span> (a[index] &gt;&gt; bit_index) &amp; <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>🍰<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>位的集合长度和<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container></span>个哈希函数怎么确定<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>和<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container></span>的值呢？<br>可以用三个公式来确定，首先给定样本量<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>（即黑名单数量）和失误率<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.138ex" height="1.439ex" role="img" focusable="false" viewBox="0 -442 503 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g></g></g></svg></mjx-container></span>，有：<br><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.254ex;" xmlns="http://www.w3.org/2000/svg" width="12.369ex" height="3.444ex" role="img" focusable="false" viewBox="0 -967.9 5467.2 1522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1155.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(2211.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(2989.6,0)"><g data-mml-node="mrow" transform="translate(220,477.2) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(1378,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(2212,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(2378.7,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g></g><g data-mml-node="mrow" transform="translate(278.8,-377.4) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(1223,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(1389.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="msup" transform="translate(1889.7,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mn" transform="translate(422,289) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><rect width="2237.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></span><br><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="12.757ex" height="2.397ex" role="img" focusable="false" viewBox="0 -706.5 5638.5 1059.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(798.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(1854.6,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(2688.6,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(2855.2,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(3577.4,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mfrac" transform="translate(4577.7,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(318.3,-345) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><rect width="820.8" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></span><br><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.72ex;" xmlns="http://www.w3.org/2000/svg" width="20.449ex" height="4.2ex" role="img" focusable="false" viewBox="0 -1538.3 9038.5 1856.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(536,-176.7) scale(0.707)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">真</text></g></g><g data-mml-node="mo" transform="translate(1570.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(2626.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(3015.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3737.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(4738.1,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,652.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(778,0)"><g data-mml-node="mrow" transform="translate(220,761.7) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msub" transform="translate(1378,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mi" transform="translate(554,-396.4)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">真</text></g></g></g><g data-mml-node="msub" transform="translate(581,-345) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(911,-396.4)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">真</text></g></g><rect width="2308.6" height="60" x="120" y="220"></rect></g></g></g><g data-mml-node="msup" transform="translate(7639.4,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" transform="translate(422,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mi" transform="translate(554,-176.7) scale(0.707)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">真</text></g></g></g></g></g></g></svg></mjx-container></span><br>前两个公式计算出的是理论上的集合长度和理论上的哈希函数个数，实际中集合长度可以更大一些即<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.72ex;" xmlns="http://www.w3.org/2000/svg" width="3.774ex" height="1.72ex" role="img" focusable="false" viewBox="0 -442 1668.1 760.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(911,-176.7) scale(0.707)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">真</text></g></g></g></g></svg></mjx-container></span>，而哈希函数个数需要采用上取整的方式即<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.72ex;" xmlns="http://www.w3.org/2000/svg" width="9.171ex" height="2.417ex" role="img" focusable="false" viewBox="0 -750 4053.7 1068.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mi" transform="translate(554,-176.7) scale(0.707)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">真</text></g></g><g data-mml-node="mo" transform="translate(1588.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(2644.7,0)"><path data-c="2308" d="M174 734Q178 746 190 750H298H369Q400 750 411 747T422 730T411 713T372 709Q365 709 345 709T310 710H214V-235Q206 -248 196 -250Q192 -250 189 -249T184 -247T180 -244T178 -241T176 -237T174 -234V734Z"></path></g><g data-mml-node="mi" transform="translate(3088.7,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(3609.7,0)"><path data-c="2309" d="M21 717T21 730T32 746T75 750H147H256Q266 742 269 735V-235Q262 -248 251 -250Q247 -250 244 -249T239 -247T235 -244T233 -241T231 -237T229 -234V710H133Q119 710 99 710T71 709Q43 709 32 713Z"></path></g></g></g></svg></mjx-container></span>，以此再次求得真实的失误率。</p>
<h2 id="一致性哈希">7.3 一致性哈希</h2>
<p>服务器利用hash
key进行划分做负载均衡，尽量选取种类多，且分布较均匀的key。否则会导致某些服务器资源利用过多（如某些key使用很多，但另一些使用很少）。如果后期需要增加服务器或者减少，则会导致数据迁移，而这个数据迁移是全量的迁移。<br>为了解决数据迁移的问题，可以将进行hash运算过后的数值范围看作一个环，将服务器分配到hash环上，然后访问或添加时，计算hash值后，判断结果距离哪个服务器的hash值最近（可以统一采用顺时针的方式），这样之后如果要添加服务器m4（假设计算后位于m2和m3中间），数据只需要迁移m2和m4之间的数据到m4中即可。大大减小了迁移量，但是这会引起新的问题：</p>
<ol type="1">
<li>无法保证初始分配的节点比较少时是均匀分配的（hash计算能保证大数据量的情况下是均分的）</li>
<li>添加一个节点后也不能保证添加之后是均分的</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/10356726/1720007779493-3980c896-2a54-4cd9-b339-34ec0b18fa5f.jpeg"><br>解决方式：虚拟节点<br>假设m1有1000个（虚拟）节点名称：(a1,
a2, a3, ...,
a1000），m2和m3同理<br>将这3000个虚拟节点计算hash后分布到hash环中，数据量较大，可以保证分配比较均匀。<br>同时如果加入节点，也是按照虚拟节点加入，也能保证加入后的分布较均匀。<br>还有一个好处是，如果m1的性能较好，可以给m1设置较多的虚拟节点，让更多的数据分配到m1，如果m3性能较差可以分配较少的虚拟节点，以进行服务器负载的管理。</p>
<h1 id="有序表并查集">8 有序表、并查集</h1>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/10356726/1720009546622-ab6207f7-b3a8-4a58-bd76-7f3a60616fff.png#averageHue=%23f6f6f6&amp;clientId=u5294c0b3-623e-4&amp;from=paste&amp;height=420&amp;id=uffd4bdfe&amp;originHeight=525&amp;originWidth=1241&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=176165&amp;status=done&amp;style=none&amp;taskId=u02b82838-e55b-4838-b8a4-c49c23d7892&amp;title=&amp;width=992.8" alt="image.png"><br><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">岛屿问题<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;m, <span class="type">int</span> N, <span class="type">int</span> M)</span> </span>{</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) {</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) {</span><br><span class="line">                ret++;</span><br><span class="line">                <span class="built_in">dfs</span>(m, i, j, N, M);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;m, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> N, <span class="type">int</span> M)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    m[i][j] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">    <span class="built_in">dfs</span>(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">    <span class="built_in">dfs</span>(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">    <span class="built_in">dfs</span>(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>时间复杂度<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.639ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4702.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2262.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(3262.4,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mo" transform="translate(4313.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span><br>⭐进阶：利用并行算法解决这个问题<br>视频链接：<a class="link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?t=4095.4&amp;p=13">左神视频链接<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="并查集">8.1 并查集</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] p;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="comment">// 初始化，设置每个元素的父元素都为自己</span></span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            p[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x != p[x]) {</span><br><span class="line">            <span class="comment">// 查找同时优化节点，减少树的层数</span></span><br><span class="line">            p[x] = find(p[x]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">pa</span> <span class="operator">=</span> find(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pb</span> <span class="operator">=</span> find(b);</span><br><span class="line">        <span class="keyword">if</span> (pa != pb) {</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="kmp算法">9 KMP算法</h1>

                </div>
                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                左神算法笔记
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                392b1809e817/左神算法笔记/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    作者
                </div>
                <div class="content">yatbfm</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    发布于
                </div>
                <div class="content">2024-09-23 21:39</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    许可
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/0311e040ed6b/css%E5%9F%BA%E7%A1%80/"
                                   title="CSS基础"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">CSS基础</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/63396b583d7a/react%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"
                                   title="React基础学习"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">React基础学习</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">1 时间复杂度和排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-text">1.1 交换两个数的写法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">1.2 找到数组中出现奇数次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%87%E8%AE%BE%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E6%95%B0%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1"><span class="nav-text">1.2.1 假设只有一种数出现奇数次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%95%B0%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1"><span class="nav-text">1.2.2 假设有两种数出现奇数次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">1.3 插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#master%E5%85%AC%E5%BC%8F"><span class="nav-text">1.4 Master公式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">1.5 归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">1.6 快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">1.7 堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E6%89%A9%E5%B1%95%E9%A2%98"><span class="nav-text">1.8 堆排序扩展题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">1.9 基数排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-text">2 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A4%E6%96%AD"><span class="nav-text">2.1 回文链表的判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">2.2 随机链表的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-1"><span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-1"><span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%85%A5%E7%8E%AF%E8%8A%82%E7%82%B9"><span class="nav-text">2.3
判断一个链表是否有环，以及返回入环节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-2"><span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-2"><span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="nav-text">2.4 判断两个链表是否相交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text">2.5 找到两个有序链表相同的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E9%93%BE%E8%A1%A8%E6%8C%89%E6%9F%90%E4%B8%AA%E5%80%BC%E5%88%86%E4%B8%BA%E5%B0%8F%E4%BA%8E-%E7%AD%89%E4%BA%8E-%E5%A4%A7%E4%BA%8E%E7%9A%84%E9%83%A8%E5%88%86"><span class="nav-text">2.6
把链表按某个值分为小于 等于 大于的部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%E5%81%9A%E6%B3%95"><span class="nav-text">入门做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%81%9A%E6%B3%95"><span class="nav-text">高级做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">链表快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">链表归并排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-text">3.1 遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-text">3.1.1 前中后序遍历（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">3.1.2 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%80%E5%B1%82%E6%9C%80%E5%A4%9A%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-text">3.2
求二叉树一层最多的节点个数（每一层的节点个数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="nav-text">3.3 二叉树的最大宽度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.4 判断是否是完全二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.5 判断满二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.6 判断平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">3.7 判断是否是二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9"><span class="nav-text">3.8
找到二叉树两个节点的最低公共祖先节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="nav-text">3.9 二叉搜索树的中序后继</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">3.10 二叉树的序列化与反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.11 判断是否是二叉树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-text">4 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">4.1 图的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">4.2 宽度优先遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">4.3 深度优先遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">4.4 拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kruskal%E7%AE%97%E6%B3%95"><span class="nav-text">4.5 Kruskal算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prim%E7%AE%97%E6%B3%95"><span class="nav-text">4.6 Prim算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80trie%E6%A0%91"><span class="nav-text">4.7 前缀Trie树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="nav-text">4.8 迪杰斯特拉算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-text">5 贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%9A%E8%AE%AE%E5%AE%89%E6%8E%92"><span class="nav-text">5.1 会议安排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2 字符串数组排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%91%E6%9D%A1%E5%88%92%E5%88%86"><span class="nav-text">5.3 金条划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E6%B6%A6%E6%9C%80%E5%A4%A7"><span class="nav-text">5.4 利润最大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">5.5 数据流的中位数(堆的应用)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="nav-text">6 暴力递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">6.1 字符串全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6"><span class="nav-text">6.2 预测赢家</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-text">6.3 解码方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-text">6.4 n皇后问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">7 哈希函数与哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-text">7.1 例题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">7.2 布隆过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-text">7.3 一致性哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">8 有序表、并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">8.1 并查集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="nav-text">9 KMP算法</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2025
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">yatbfm</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">1 时间复杂度和排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-text">1.1 交换两个数的写法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">1.2 找到数组中出现奇数次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%87%E8%AE%BE%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E6%95%B0%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1"><span class="nav-text">1.2.1 假设只有一种数出现奇数次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%95%B0%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1"><span class="nav-text">1.2.2 假设有两种数出现奇数次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">1.3 插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#master%E5%85%AC%E5%BC%8F"><span class="nav-text">1.4 Master公式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">1.5 归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">1.6 快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">1.7 堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E6%89%A9%E5%B1%95%E9%A2%98"><span class="nav-text">1.8 堆排序扩展题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">1.9 基数排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-text">2 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A4%E6%96%AD"><span class="nav-text">2.1 回文链表的判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">2.2 随机链表的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-1"><span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-1"><span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%85%A5%E7%8E%AF%E8%8A%82%E7%82%B9"><span class="nav-text">2.3
判断一个链表是否有环，以及返回入环节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-2"><span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-2"><span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="nav-text">2.4 判断两个链表是否相交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text">2.5 找到两个有序链表相同的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E9%93%BE%E8%A1%A8%E6%8C%89%E6%9F%90%E4%B8%AA%E5%80%BC%E5%88%86%E4%B8%BA%E5%B0%8F%E4%BA%8E-%E7%AD%89%E4%BA%8E-%E5%A4%A7%E4%BA%8E%E7%9A%84%E9%83%A8%E5%88%86"><span class="nav-text">2.6
把链表按某个值分为小于 等于 大于的部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%E5%81%9A%E6%B3%95"><span class="nav-text">入门做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%81%9A%E6%B3%95"><span class="nav-text">高级做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">链表快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">链表归并排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-text">3.1 遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-text">3.1.1 前中后序遍历（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">3.1.2 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%80%E5%B1%82%E6%9C%80%E5%A4%9A%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-text">3.2
求二叉树一层最多的节点个数（每一层的节点个数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="nav-text">3.3 二叉树的最大宽度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.4 判断是否是完全二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.5 判断满二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.6 判断平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">3.7 判断是否是二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9"><span class="nav-text">3.8
找到二叉树两个节点的最低公共祖先节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="nav-text">3.9 二叉搜索树的中序后继</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">3.10 二叉树的序列化与反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.11 判断是否是二叉树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-text">4 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">4.1 图的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">4.2 宽度优先遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">4.3 深度优先遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">4.4 拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kruskal%E7%AE%97%E6%B3%95"><span class="nav-text">4.5 Kruskal算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prim%E7%AE%97%E6%B3%95"><span class="nav-text">4.6 Prim算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80trie%E6%A0%91"><span class="nav-text">4.7 前缀Trie树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="nav-text">4.8 迪杰斯特拉算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-text">5 贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%9A%E8%AE%AE%E5%AE%89%E6%8E%92"><span class="nav-text">5.1 会议安排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2 字符串数组排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%91%E6%9D%A1%E5%88%92%E5%88%86"><span class="nav-text">5.3 金条划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E6%B6%A6%E6%9C%80%E5%A4%A7"><span class="nav-text">5.4 利润最大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">5.5 数据流的中位数(堆的应用)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="nav-text">6 暴力递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">6.1 字符串全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6"><span class="nav-text">6.2 预测赢家</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-text">6.3 解码方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-text">6.4 n皇后问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">7 哈希函数与哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-text">7.1 例题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">7.2 布隆过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-text">7.3 一致性哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">8 有序表、并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">8.1 并查集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="nav-text">9 KMP算法</span></a></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->


<div class="">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        
            
<script src="/js/post/copyright-info.js"></script>

        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->

    
<script src="//cdn.jsdelivr.net/npm/mermaid@10.5.0/dist/mermaid.min.js"></script>






<!-- pjax -->



    
        
            
<script class="custom-inject-js" src="/js/custom.js" data-pjax></script>

        
    

</body>
</html>
