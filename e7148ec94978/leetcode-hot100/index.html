<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Keep Studying">
    <meta name="author" content="yatbfm">
    
    <title>
        
            LeetCode Hot100 |
        
        yatbfm&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/image.png">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
        
            
                
<link rel="stylesheet" href="/css/custom.css">

            
        
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"yatbfm.github.io","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"yatbfm's blog","author":"yatbfm","favicon":"/images/image.png"},"menu":{"Home":"/","Archives":"/archives","Categories":"/categories","Tags":"/tags"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep studying.","hitokoto":true},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":true},"home":{"category":true,"tag":true,"announcement":null},"post":{"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm","copyright_info":true},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":false,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":true,"css":["/css/custom.css"],"js":["/js/custom.js"]},"root":"","source_data":{},"version":"4.1.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
            <a class="site-name border-box" href="/">
               yatbfm&#39;s blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                首页
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                归档
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                
                                分类
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >首页</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags"
                    >标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        LeetCode Hot100
                    </div>
                

                
                    <div class="post-header border-box">
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">yatbfm</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2023-12-01 21:39</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Wed Apr 16 2025 07:47:24 GMT+0000">2025-04-16 07:47</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/LeetCode/">LeetCode</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>19.2k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>88 分钟</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <meta name="referrer" content="no-referrer">
<h1 id="盛最多水的容器">盛最多水的容器</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
如果使用两层<code>for</code>循环会导致超时。<br>
使用双指针从左右边界向内收缩，依次缩减范围，直到两个指针相遇，具体收缩步骤：</p>
<span id="more"></span>
<ol type="1">
<li>计算体积，比较大小</li>
<li>比较左右指针所在位置的高度</li>
<li>高度低的向内收缩</li>
</ol>
<p>🍰 证明：<br>
假设左右指针分别为<code>i, j</code>所在位置的高度为<code>x, y</code>，用<code>S(i, j)</code>表示指针位置形成的体积大小。这里假设<code>x &lt; y</code>。如果按照上述收缩思路的话，应该是<code>i</code>向右移，形成的体积大小是<code>S(i + 1, j)</code>。这里会有疑问的是丢失了<code>S(i, j - 1), S(i, j - 2), ..., S(i, i + 1)</code>的状态。下面证明这些状态都小于<code>S(i, j)</code>。<br>
首先设<code>j - i</code>的长度为<code>w</code>，然后丢失状态的所有容器的长度<code>(j - t) - i</code>设为<code>w'</code>都一定小于<code>w</code>。<br>
丢失状态中的<code>i</code>指针不动，高度为<code>x</code>，右指针向内收缩，高度设为<code>y'</code>，可以知道<code>y'</code>和<code>y</code>的大小关系不确定。分为两种情况：</p>
<ol type="1">
<li><code>y' &gt; y</code>，那么<code>S(i, j - t)</code>的体积为<code>w' * x</code>，一定小于<code>S(i, j) = w * x</code>。</li>
<li><code>y' &lt;= y</code>，那么<code>S(i, j - t)</code>的体积为<code>min(x, y') * w'</code>
<ol type="1">
<li><code>x &gt; y'</code>，<code>S(i, j - t) = y' * w'</code>一定小于<code>w * x</code></li>
<li><code>x &lt;= y'</code>，<code>S(i, j - t) = x * w'</code>一定小于<code>w * x</code></li>
</ol></li>
</ol>
<p>所以如果移动高位置的指针，一定会导致容器体积减小，移动低位置的可能会使得容器体积增大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = height.length - <span class="number">1</span>; i &lt; j;) {</span><br><span class="line">            result = Math.max(result, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j]) {</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="三数之和">三数之和</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
如果使用三层<code>for</code>循环会超时。<br>
这里使用双指针，首先对数组进行排序，然后固定指针<code>k</code>，取另外两个指针<code>i j</code>分别在<code>k + 1, nums.length - 1</code>的位置，然后判断：</p>
<ol type="1">
<li><code>nums[k] + nums[i] + nums[j] &gt; 0</code>则整体偏大，需要减小，可以让<code>j--</code></li>
<li><code>nums[k] + nums[i] + nums[j] &lt; 0</code>则整体偏小，需要增大，可以让<code>i++</code></li>
<li>否则满足条件，加入结果列表</li>
</ol>
<p>这里需要注意要排除重复的三元组，因此在移动指针时需要判断后续判断的值是否和当前值冲突</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length; k++) {</span><br><span class="line">            <span class="comment">// 排除重复元素，如果k和k-1位置的数一样，那么后续计算的结果一定一样，因此需要排除</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果nums[k] &gt; 0，那么nums[i]和nums[j]一定 &gt; 0，结果一定 &gt; 0</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span> resultList;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = nums.length - <span class="number">1</span>; i &lt; j;) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 跳过重复数值，只取重复的最后一个</span></span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    resultList.add(Arrays.asList(nums[k], nums[i], nums[j]));</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="最长连续序列">最长连续序列</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
本题要求时间复杂度为<code>O(n)</code>，如果直接排序的话复杂度达到<code>O(nlogn)</code>。<br>
要找出连续序列的长度，可以换个思路，如果找到一个数<code>nums[i]</code>，然后将这个数一直<code>+1</code>，加完后的数在数组里还能找到那就说明连续序列的长度可以增加
1。因此满足这个条件的话需要使用到哈希，将所有的数保存在一个集合中，方便查询。<br>
这里的一个优化是如果当前数减 1
之后还能在数组中找到，那么可以直接跳过，因为减 1
之后的数在计算序列长度时已经包含了当前数，从当前数开始计算的长度一定不如减
1 之后的数计算的序列长度长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            numSet.add(num);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            <span class="comment">// 如果包含减1之后的数，那么直接跳过，因为之前已经计算过</span></span><br><span class="line">            <span class="keyword">if</span> (numSet.contains(num - <span class="number">1</span>)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempResult</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num;</span><br><span class="line">            <span class="comment">// 如果加1后还在数组里能找到，序列长度加1</span></span><br><span class="line">            <span class="keyword">while</span> (numSet.contains(++temp)) {</span><br><span class="line">                tempResult++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 保存最大的序列长度</span></span><br><span class="line">            result = Math.max(result, tempResult);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="接雨水">接雨水</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
根据题意，最两侧的柱子不能接到雨水，只能作为墙壁。考虑<strong>按列求</strong>，单独考虑每个柱子可以接到的雨水。<br>
当前柱子可以接到的雨水由当前柱子<strong>左侧和右侧</strong>的最高的柱子包裹起来，可以保证接到雨水，而接到的雨水的多少则是右两则最高的柱子中的<strong>矮</strong>的决定（木桶效应）。如果矮的柱子比当前柱子高，那么接到的雨水就是高度的差值，否则接不到雨水。<br>
那么现在的问题是怎么快速求出<strong>当前柱子左侧最高的高度</strong>和<strong>当前柱子右侧最高的高度</strong>。</p>
<ol type="1">
<li>动态规划</li>
</ol>
<p>使用一个<strong>数组</strong>记录当前位置左侧（不包括自身）最高的高度是多少，即<code>maxLeft[i] = max(maxLeft[i - 1], height[i - 1])</code>，右侧同理<br>
这会使用到<code>O(n)</code>的空间复杂度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> {</span><br><span class="line">        <span class="type">int</span>[] maxLeft = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        <span class="type">int</span>[] maxRight = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) {</span><br><span class="line">            maxLeft[i] = Math.max(maxLeft[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> height.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            maxRight[i] = Math.max(maxRight[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(maxLeft[i], maxRight[i]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> min - height[i];</span><br><span class="line">            sum += sub &gt; <span class="number">0</span> ? sub : <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="无重复字符的最长子串">无重复字符的最长子串</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
本题可以使用滑动窗口“框住”没有重复字符的子串，遍历完成后最长的窗口长度即为答案。<br>
怎么保证滑动窗口中没有重复字符串呢？使用哈希表存储。<br>
首先使用两个指针<code>j, i</code>为滑动窗口的边界，表示<code>[j, i]</code>区间的字符串都不重复。并且使用一个<code>Set</code>集合保存该窗口中的字符，遍历时如果待加入的字符已经存在了，则一直遍历删除窗口左端的字符直到没有重复的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; chs.length; i++) {</span><br><span class="line">            <span class="keyword">while</span> (set.contains(chs[i])) {</span><br><span class="line">                set.remove(chs[j++]);</span><br><span class="line">            }</span><br><span class="line">            set.add(chs[i]);</span><br><span class="line">            result = Math.max(result, set.size());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="和为-k-的子数组">和为 K 的子数组</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
要求数组中的子数组的和，子数组定义为：连续非空序列。可以理解为一段<strong>区间内数值的和</strong>，这样可以想到使用<strong>前缀和</strong>来计算，前缀和数组<code>preSum[i]</code>表示原数组<code>nums</code>中第一个数一直加到第<code>i</code>个数的和，如果表示某一段区间<code>[j, i]</code>的和，计算<code>preSum[i] - preSum[j - 1]</code>即可。<br>
需要注意的是：前缀和数组的长度一般比原数组多一个，多余的一个数表示的是数组中第
0 个数到第 0
个数（即没有任何数的情况下）的和，同时这样做也为了编码简便。<br>
❓ 代码中初始时加入的<code>(0, 1)</code>键值对表示前缀和为 0
的有一个（前缀和中什么数都没有），暂时还不理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(preSum, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 计算前缀和，一般下标从1开始，0下标用于表示没有数的时候的前缀和。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) {</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (mp.containsKey(preSum[i] - k)) {</span><br><span class="line">                result += mp.get(preSum[i] - k);</span><br><span class="line">            }</span><br><span class="line">            mp.put(preSum[i], mp.getOrDefault(preSum[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="滑动窗口最大值">滑动窗口最大值</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
滑动窗口求最大值通常使用<strong>单调队列</strong>，但是具体实现采用<strong>双端队列</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="type">int</span>[] resultArr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - (k - <span class="number">1</span>)];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span> - k; i &lt; nums.length; i++, j++) {</span><br><span class="line">            <span class="comment">// 如果被删除的值正好是之前窗口中最大的元素，则需要在队列中移除。</span></span><br><span class="line">            <span class="comment">// 保证队列中的元素都在窗口中</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; deque.getFirst() == nums[j - <span class="number">1</span>]) {</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 从队列尾部加入元素，加入前判断队列尾部的值是否小于要加入的值，小于则删除</span></span><br><span class="line">            <span class="keyword">while</span> (deque.size() != <span class="number">0</span> &amp;&amp; deque.getLast() &lt; nums[i]) {</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            }</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) {</span><br><span class="line">                resultArr[j] = deque.getFirst();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>另一种写法，队列中保存的是窗口中元素的下标，通过下标判断元素是否在窗口中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="type">int</span>[] resultArr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - (k - <span class="number">1</span>)];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span> - k; i &lt; nums.length; i++, j++) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; deque.getFirst() &lt; j) {</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (deque.size() != <span class="number">0</span> &amp;&amp; nums[deque.getLast()] &lt; nums[i]) {</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            }</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) {</span><br><span class="line">                resultArr[j] = nums[deque.getFirst()];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="最小覆盖子串">最小覆盖子串</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
使用<strong>滑动窗口，窗口由两个指针控制大小，右指针负责扩大窗口，左指针负责收缩窗口。如果当前窗口不覆盖子串，则扩大窗口，如果覆盖子串，则收缩窗口更新结果，直至不能收缩。</strong></p>
<p>❓<strong>问题在于如何判断是否覆盖？</strong></p>
<p>可以使用哈希表存储窗口中每个字符出现的次数，如果目标字符串中的字符出现的次数都<strong>小于等于</strong>窗口中的，则说明覆盖，否则不覆盖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> {</span><br><span class="line">        <span class="type">char</span>[] chsArr = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] chtArr = t.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; chCntMp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : chtArr) {</span><br><span class="line">            chCntMp.put(ch, chCntMp.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        Map&lt;Character, Integer&gt; winMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ansLeft</span> <span class="operator">=</span> -<span class="number">1</span>, ansRight = chsArr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; chsArr.length; i++) {</span><br><span class="line">            winMap.put(chsArr[i], winMap.getOrDefault(chsArr[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (isCover(winMap, chCntMp)) {</span><br><span class="line">                <span class="keyword">if</span> (i - j + <span class="number">1</span> &lt; ansRight - ansLeft + <span class="number">1</span>) {</span><br><span class="line">                    ansRight = i;</span><br><span class="line">                    ansLeft = j;</span><br><span class="line">                }</span><br><span class="line">                winMap.put(chsArr[j], winMap.get(chsArr[j++]) - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ansLeft == -<span class="number">1</span> ? <span class="string">""</span> : s.substring(ansLeft, ansRight + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCover</span><span class="params">(Map&lt;Character, Integer&gt; s, Map&lt;Character, Integer&gt; t)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt; t.size()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : t.entrySet()) {</span><br><span class="line">            <span class="keyword">if</span> (s.getOrDefault(entry.getKey(), <span class="number">0</span>) &lt; entry.getValue()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="最大子数组和">最大子数组和</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/maximum-subarray/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
利用<strong>动态规划</strong>可以达到<code>O(N)</code>的时间复杂度。<br>
假定<code>dp[i]</code>表示以第 i
个数结尾的最大的子数组的和，所以递归公式：<code>dp[i] = max(dp[i - 1] + nums[i], nums[i])</code>，如果前一个子数组加上<code>nums[i]</code>数组和变小，就认为最大的数组是<code>nums[i]</code>自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line">                nums[i] = Math.max(nums[i], nums[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">            }</span><br><span class="line">            ans = Math.max(ans, nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="轮转数组">轮转数组</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&amp;envId=top-100-liked<i class="fas fa-external-link-alt"></i></a><br>
主要是空间复杂度达到<code>O(1)</code>，不适用额外的数组。<br>
可以采用基于交换的方式，通过观察结果，可以发现，向右移动 k
个单位后，后边 k 个数移动到前 k 个位置，其余的移动到了后 k
个位置。如果先采用整体翻转的方式，可以将后 k 的数移动到前 k
个位置，但是顺序和正确的顺序相反，因此再对局部进行依次翻转即可。<br>
❗ 这里有一个需要注意：如果轮转的长度
k，大于数组长度，可以采用一次取模操作，当 k
和数组长度相等时，轮转后和原数组相同，所以可以认为 k
取模后的结果为真实的需要轮转的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> {</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; i++, j--) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="缺失的第一个正数">缺失的第一个正数</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&amp;envId=top-100-liked">41.
缺失的第一个正数 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>难点在于不能使用额外空间。如果可以使用额外空间，可以使用哈希表，存储每一个元素，然后从
1 开始遍历，直到发现不存在于哈希表中的值即可。</p>
<p>如果要降低空间复杂度，可以考虑<strong>原地哈希</strong>。</p>
<p>通过观察结果，会发现，结果肯定存在于[1, n+1]中，n
为数组长度，如果数组中的数在[1, n]都存在，则说明结果为 n + 1，否则为[1,
n]中不存在的最小的数，这里可以使用原地哈希，具体方法可以采用<strong>标记法</strong>，遍历数组，如果
nums[i]范围在[1, n]中，则给 nums[nums[i] -
1]打上标记，这里打标记可以设置为负数，因为原数组中存在负数，可以令原来的负数设为一个不可能的值，如
n + 1
或者更大，这样所有数都是正数了。当遍历完所有打完标记，如果所有的数都是负数了，说明都存在了，否则为第一个不为负数的下标+
1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) {</span><br><span class="line">                nums[i] = nums.length + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="number">1</span> &amp;&amp; temp &lt;= nums.length) {</span><br><span class="line">                nums[temp - <span class="number">1</span>] = -Math.abs(nums[temp - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="旋转图像">旋转图像</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&amp;envId=top-100-liked">48.
旋转图像 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a><br>
通过观察例子中的旋转，固定的位置之间会形成一个完整的旋转链，因此可以使用原地操作数据，不需要使用新的二维数组。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/svg/10356726/1721746452221-0e481ef9-c00d-4687-8c5a-c32f611f9d62.svg"></p>
<p>所以接下来的重点是寻找旋转链之间的对应的坐标关系。以左上角的<code>(i, j)</code>为例，</p>
<p>旋转一次后的坐标为：<code>(j, n - i - 1)</code>，可以理解为，<code>(i, j)</code>所在的列变成了行，行变成了列。从行看，<code>i</code>行的数据会变成列，行是从上往下数，那么变成列后就是从右往左数，所以列就是<code>n - i - 1</code>。从列看，从左向右看，变成行就是从上往下看，因此就是<code>j</code>。</p>
<p><code>(j, n - i - 1)</code>再旋转一次后，坐标为：<code>(n - i - 1, n - j - 1)</code>，从行看，是从上往下，旋转后的列则是从右向左，所以是<code>n - j - 1</code>。从列看，从右往左，旋转后的行则是从下往上，<code>n - i - 1</code></p>
<p>依此类推：<code>(n - j - 1, i)</code></p>
<p>最后的坐标旋转链<code>(i, j) -&gt; (j, n - i - 1) -&gt; (n - i - 1, n - j - 1) -&gt; (n - j - 1, i) -&gt; (i, j)</code></p>
<p>因此，原地操作只需要按照这个顺序依次赋值即可。</p>
<p>接下来需要考虑的是，遍历哪些数据进行旋转操作。只有两种情况，n
为奇数和偶数的情况。</p>
<p>n 为偶数：只需要考虑左上角 行<code>[0, n / 2)</code>
列<code>[0, n / 2)</code>的情况</p>
<p>n
为奇数：不需要考虑正中心的数，然后需要旋转的则是正中心左方和上方组成的区域，即
行<code>[0, n / 2)</code> 列<code>[0, n / 2]</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/10356726/1721746466809-b12d8f72-49ae-4853-a06c-e1efcd8637ed.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; j++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i];</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="相交链表">相交链表</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">160.
相交链表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>判断两个链表是否相交，可以使用双指针的方式，题目中保证链表中不存在环，因此大大简化了判断条件。</p>
<p>两个指针分别遍历两个链表，当遍历到末尾时再遍历另一个链表，直到指向相同的节点，即为相交的第一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) {</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> {</span><br><span class="line">        <span class="keyword">return</span> getIntersectionNode(headA, headB, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB, ListNode endNode)</span> {</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) {</span><br><span class="line">            pA = pA == endNode ? headB : pA.next;</span><br><span class="line">            pB = pB == endNode ? headA : pB.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>❓ 如果链表中存在环呢？则需要考虑多种情况。</p>
<p>这里认为链表都是单链表</p>
<ol type="1">
<li>情况 1：两个链表都无环双指针，遍历链表 A 和 B，当指针为 null
时从另一个节点的头节点开始遍历。直到两个指针相等（两个指针相等时，如果为
null 则表示没有相交节点，否则有相交节点）<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1395092/lian-biao-xiang-jiao-by-leetcode-solutio-2kne/">面试题
02.07. 链表相交 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> {</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) {</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>❗<strong>注意</strong>：判断是否为<code>null</code>时，使用的是<code>pA</code>当前指针，而不是<code>pA.next</code>，如果使用<code>pA.next</code>来判断，当不相交时，会发生无限循环的情况，<code>pA</code>和<code>pB</code>会一直不相等（也不为<code>null</code>)。所以使用<code>pA</code>当前指针。可以理解为，把最后链表结束时指向的<code>null</code>指针也算作一个节点，然后两个链表不相交时，最后都会指向<code>null</code>节点，那么两个链表就在<code>null</code>节点“相交”了，如下图所示。</p>
<p><img src="https://cdn.nlark.com/yuque/__mermaid_v3/be9f1cca97ccfc28c1323ef985ae5a99.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJmbG93Y2hhcnQgTFJcblx0MSAtLS0-IDJcblx0MiAtLS0-IDNcblx0MyAtLS0-IG51bGxcblx0NCAtLS0-IDVcblx0NSAtLS0-IG51bGwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19tZXJtYWlkX3YzL2JlOWYxY2NhOTdjY2ZjMjhjMTMyM2VmOTg1YWU1YTk5LnN2ZyIsImlkIjoiREJMN3AiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9#id=aHzmc&amp;originHeight=134&amp;originWidth=434&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<ol start="2" type="1">
<li>情况
2：一个有环一个无环（一定不相交）如果相交，则肯定有一个节点有两个<code>next</code>指针，这不满足单链表。所以一定不相交。</li>
<li>情况 3：两个都有环
<ul>
<li>不相交</li>
<li>在非环处相交</li>
<li>在环处相交</li>
</ul></li>
</ol>
<p>相交只有两种情况</p>
<p><img src="http://pfmiles.github.io/images/circledLinkedListsIntersections.png#id=oWbz7&amp;originHeight=196&amp;originWidth=308&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=#id=IK96b&amp;originHeight=196&amp;originWidth=308&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title="></p>
<p>找到两个带环链表的入环节点，然后固定一个，遍历另一个，直到能找到一个节点和固定节点相等，则证明相交，否则不相交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleNode1 circleNode2是两个节点的入环节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果入环节点相同，说明必然是情况1。否则是情况2或者不相交</span></span><br><span class="line"><span class="keyword">if</span> (circleNode1 == circleNode2) {</span><br><span class="line">    <span class="comment">// 利用circleNode1或者2为末尾节点，利用无环链表求相交节点方式求相交的节点。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> circleNode2.next;</span><br><span class="line"><span class="keyword">while</span>(temp != circleNode2) {</span><br><span class="line">    <span class="keyword">if</span>(temp == circleNode1)</span><br><span class="line">        <span class="comment">// circleNode1 或者  circleNode2为相交节点都可以</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    temp = temp.next;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 不相交</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>所以所有情况如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/10356726/1721746488712-074b6bf1-ce3f-462f-8113-d26e0cc2ae91.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cycleNodeA</span> <span class="operator">=</span> hasCycle(headA);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cycleNodeB</span> <span class="operator">=</span> hasCycle(headB);</span><br><span class="line">    <span class="keyword">if</span> (cycleNodeA == cycleNodeB) {</span><br><span class="line">        <span class="comment">// 说明两个都是无环的，直接判断是否相交</span></span><br><span class="line">        <span class="comment">// if (cycleNodeA == null) {</span></span><br><span class="line">        <span class="comment">//     return getIntersectionNodeNoLoop(headA, headB, null);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="comment">// 否则是都有环，入环节点相同，必然相交，以入环节点为终止节点求相交节点</span></span><br><span class="line">        <span class="comment">// return getIntersectionNodeNoLoop(headA, headB, cycleNodeA);</span></span><br><span class="line">        <span class="comment">// 以上代码可以直接合并为下面一行</span></span><br><span class="line">        <span class="keyword">return</span> getIntersectionNodeNoLoop(headA, headB, cycleNodeA);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 说明两个入环节点不相等，要么有一个为空，要么都不为空，如果有一个为空，则表示肯定不相交</span></span><br><span class="line">    <span class="keyword">if</span> (cycleNodeA == <span class="literal">null</span> || cycleNodeB == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果环上相交，说明从一个入环节点开始遍历，一定能到达另一个入环节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cycleNodeA;</span><br><span class="line">    <span class="keyword">while</span> (temp != cycleNodeB) {</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        <span class="comment">// 转了一圈发现回到原位置了，说明没有相交</span></span><br><span class="line">        <span class="keyword">if</span> (temp == cycleNodeA) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 相交，任意一个入环节点都可以是相交节点。</span></span><br><span class="line">    <span class="keyword">return</span> cycleNodeA;</span><br><span class="line">    <span class="comment">// 如果入环节点不同，并且相交，那么肯定有两个相交节点</span></span><br><span class="line">    <span class="comment">// return cycleNodeB;</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 判断一个链表是否有环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) {</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow) {</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 判断两个无环链表是否相交，手动设定终止节点endNode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getIntersectionNodeNoLoop</span><span class="params">(ListNode headA, ListNode headB, ListNode endNode)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) {</span><br><span class="line">        pA = pA == endNode ? headB : pA.next;</span><br><span class="line">        pB = pB == endNode ? headA : pB.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="反转链表">反转链表</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/?envType=study-plan-v2&amp;envId=top-100-liked">206.
反转链表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>使用三个指针分别指向“上一个节点”“当前节点”和“下一个节点”，遍历过程中反转“上一个节点”和“当前节点”的指向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="回文链表">回文链表</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/?envType=study-plan-v2&amp;envId=top-100-liked">234.
回文链表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>需要使用<code>O(1)</code>的空间复杂度，回文的定义：从前向后和从后向前遍历的结果相同。但是原链表是单向链表，因此如果想从后向前遍历，需要将后半部分的链表反转。</p>
<p>因此需要判断什么时候到达了“中间”位置，然后将中间及其之后的链表反转。</p>
<p>这里使用快慢指针，因为快指针行进速度是慢指针 2
倍，所以当快指针到结尾时，慢指针行进了链表长度的一半。</p>
<p>这里分两种情况考虑，链表长度为奇数和偶数。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/svg/10356726/1721746508059-1dec74e5-f5a5-4396-b933-ecab2c05d63a.svg"></p>
<p>如图所示，当快慢指针结束时，奇数长度的链表慢指针在正中心的位置，偶数长度的链表慢指针在前半部分的最后一个节点位置。</p>
<p>通过观察可以知道，奇数长度的链表正中心的节点并不影响整体的回文性，偶数长度的链表需要将后半部分的链表反转，因此可以确定<strong>需要反转的链表的头节点</strong>为<code>slow.next</code>，反转完后返回右半部分头节点，从左半部分头节点和右半部分头节点同时遍历，如果不同则直接返回<code>false</code>，需要注意终止条件是右半部分的节点走到<code>null</code>，因为链表长度为奇数时，左半部分的链表会多一个中心节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) {</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        }</span><br><span class="line">        fast = reverse(slow.next);</span><br><span class="line">        <span class="comment">// 保存反转后的链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> fast;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (fast.val != slow.val) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 链表恢复原状</span></span><br><span class="line">        reverse(temp);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="环形链表">环形链表</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked">142.
环形链表 II - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>判断链表是否有环，使用快慢指针，当快慢指针相遇时表明存在环，然后将快指针从头节点开始遍历，每次移动一个位置，直到再次相遇的节点即为环形的入口。</p>
<p>❓ 为什么将快指针从头节点开始遍历就能找到入口？下边给出证明：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/svg/10356726/1721746520996-8c006598-a04f-4082-a3a6-e8e50c669255.svg"></p>
<p>假设环形链表中三个点，头节点 A，入口节点 B，快慢指针相遇的节点
C。因为快指针的速度是慢指针的 2 倍，所以快指针行进的距离是慢指针的 2
倍，所以有<img src="https://cdn.nlark.com/yuque/__latex/265294c23be29bd87952408d0493a041.svg" alt="image">，移项可得<img src="https://cdn.nlark.com/yuque/__latex/f9da6198578e8cc9fb6418e9f5f88c38.svg" alt="image">即<img src="https://cdn.nlark.com/yuque/__latex/be03d6d62888a348418df34c0a8938da.svg" alt="image">，也就是说从 C 点和 A 点出发，以同样的速度行进，会同时到达
B 即入口节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) {</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) {</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) {</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) {</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="删除链表的倒数第-n-个节点">删除链表的倒数第 N 个节点</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&amp;envId=top-100-liked">19.
删除链表的倒数第 N 个结点 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>要求使用一趟遍历，难点在于遍历一趟就要找到第 N
个节点所在的位置。如果只用一个指针遍历长度，则需要遍历两次。</p>
<p>如果使用两个指针，让第一个指针先走<code>n - 1</code>步，然后让第二个指针和第一个指针同时行进，则可以保证两个指针的距离固定，当第一个指针到达结尾时，第二个指针的位置则为需要删除的节点，然后进行删除即可。（注意：需要多一个<code>pre</code>指针，不然无法删除）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">            first = first.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (first.next != <span class="literal">null</span>) {</span><br><span class="line">            first = first.next;</span><br><span class="line">            pre = second;</span><br><span class="line">            second = second.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        }</span><br><span class="line">        pre.next = second.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="两两交换链表中的节点">两两交换链表中的节点</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/?envType=study-plan-v2&amp;envId=top-100-liked">24.
两两交换链表中的节点 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>采用“类似头插法”方式，设置一个<code>temp</code>节点，<code>temp</code>节点指向的后续的节点即为需要交换的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ansHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">// 保证temp的后续节点存在</span></span><br><span class="line">        ansHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> ansHead;</span><br><span class="line">        <span class="comment">// 保证后续节点存在两个节点才可以交换，否则不能交换</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> temp.next.next;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            <span class="comment">// 保证链表使用是连接的，没有断开</span></span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            <span class="comment">// 进行xi</span></span><br><span class="line">            temp = node1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ansHead.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="k-个一组翻转链表">K 个一组翻转链表</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&amp;envId=top-100-liked">25.
K 个一组翻转链表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>要求 K 个一组，可以参考<a href="#p5E3a">删除链表的倒数第 N
个节点</a>，先走 K 步，然后翻转这 K 个链表，依此类推。</p>
<p>需要注意的是设置一个<code>dummy</code>节点，即带头节点，方便后续操作。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/10356726/1722764548772-f9950a64-34cf-4124-8223-07970c307150.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">ListNode</span>} <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">ListNode</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseKGroup = <span class="keyword">function</span> (<span class="params">head, k</span>) {</span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">  <span class="keyword">let</span> pre = dummy,</span><br><span class="line">    cur = dummy;</span><br><span class="line">  <span class="keyword">while</span> (cur.<span class="property">next</span> !== <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; cur; i++) {</span><br><span class="line">      cur = cur.<span class="property">next</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!cur) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">let</span> start = pre.<span class="property">next</span>,</span><br><span class="line">      end = cur.<span class="property">next</span>;</span><br><span class="line">    pre.<span class="property">next</span> = <span class="title function_">reverse</span>(start, end);</span><br><span class="line">    start.<span class="property">next</span> = end;</span><br><span class="line">    pre = start;</span><br><span class="line">    cur = start;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">};</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  head为头节点，end为最后一个节点的下一个节点（理解为null）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">head, end</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!head) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>,</span><br><span class="line">    cur = head;</span><br><span class="line">  <span class="keyword">while</span> (cur !== end) {</span><br><span class="line">    <span class="keyword">let</span> next = cur.<span class="property">next</span>;</span><br><span class="line">    cur.<span class="property">next</span> = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="随机链表的复制">随机链表的复制</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/submissions/548263517/?envType=study-plan-v2&amp;envId=top-100-liked">138.
随机链表的复制 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>方法一：</strong>哈希表，存储每个节点的对应复制的节点，然后遍历添加指针。</p>
<p><strong>方法二：</strong>
构造新链表<code>旧链表1 -&gt; 新链表1 -&gt; 旧链表2 -&gt; 新链表2 -&gt; ... -&gt; 旧链表n -&gt; 新链表n</code>，然后遍历，通过旧链表的<code>random</code>指针，找到新链表的<code>random</code>节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a _Node.</span></span><br><span class="line"><span class="comment"> * function _Node(val, next, random) {</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.next = next;</span></span><br><span class="line"><span class="comment"> *    this.random = random;</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">_Node</span>} <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">_Node</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="keyword">function</span> (<span class="params">head</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!head) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 复制链表</span></span><br><span class="line">  <span class="keyword">let</span> temp = head;</span><br><span class="line">  <span class="keyword">while</span> (temp) {</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title function_">_Node</span>(temp.<span class="property">val</span>, temp.<span class="property">next</span>, <span class="literal">null</span>);</span><br><span class="line">    temp.<span class="property">next</span> = node;</span><br><span class="line">    temp = node.<span class="property">next</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 连接新节点的random指针</span></span><br><span class="line">  temp = head;</span><br><span class="line">  <span class="keyword">while</span> (temp) {</span><br><span class="line">    <span class="keyword">if</span> (temp.<span class="property">random</span>) {</span><br><span class="line">      temp.<span class="property">next</span>.<span class="property">random</span> = temp.<span class="property">random</span>.<span class="property">next</span>;</span><br><span class="line">    }</span><br><span class="line">    temp = temp.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 拆分链表</span></span><br><span class="line">  temp = head;</span><br><span class="line">  <span class="keyword">let</span> ansHead = head.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">let</span> ansTemp = ansHead;</span><br><span class="line">  <span class="keyword">while</span> (temp) {</span><br><span class="line">    temp.<span class="property">next</span> = ansTemp.<span class="property">next</span>;</span><br><span class="line">    temp = ansTemp.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp) {</span><br><span class="line">      ansTemp.<span class="property">next</span> = temp.<span class="property">next</span>;</span><br><span class="line">      ansTemp = temp.<span class="property">next</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ansHead;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="排序链表">排序链表</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">148.
排序链表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>链表排序，通常使用归并排序。</p>
<p>利用快慢指针找到中点，然后两边分别排序、归并。</p>
<p><strong>注意</strong>的是 ?? 和 || 的区别：</p>
<ul>
<li><code>x ?? y</code>是当<code>x</code>为<code>null、undefined</code>时取
y，如果<code>x</code>为<code>false、0、''</code>这种仍然取<code>x</code>。</li>
<li><code>x || y</code>当<code>x</code>为<strong>假值</strong>即<code>null、undefined、false、0、''</code>这些值时取<code>y</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">ListNode</span>} <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">ListNode</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortList = <span class="keyword">function</span> (<span class="params">head</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) {</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> fast = head,</span><br><span class="line">    slow = head;</span><br><span class="line">  <span class="keyword">while</span> (fast.<span class="property">next</span> &amp;&amp; fast.<span class="property">next</span>.<span class="property">next</span>) {</span><br><span class="line">    fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    slow = slow.<span class="property">next</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> mid = slow.<span class="property">next</span>;</span><br><span class="line">  slow.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="title function_">sortList</span>(head);</span><br><span class="line">  <span class="keyword">let</span> right = <span class="title function_">sortList</span>(mid);</span><br><span class="line">  <span class="keyword">let</span> ansHead = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">  <span class="keyword">let</span> tail = ansHead;</span><br><span class="line">  <span class="keyword">while</span> (left &amp;&amp; right) {</span><br><span class="line">    <span class="keyword">if</span> (left.<span class="property">val</span> &lt; right.<span class="property">val</span>) {</span><br><span class="line">      tail.<span class="property">next</span> = left;</span><br><span class="line">      left = left.<span class="property">next</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      tail.<span class="property">next</span> = right;</span><br><span class="line">      right = right.<span class="property">next</span>;</span><br><span class="line">    }</span><br><span class="line">    tail = tail.<span class="property">next</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  tail.<span class="property">next</span> = left ?? right;</span><br><span class="line">  <span class="keyword">return</span> ansHead.<span class="property">next</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="合并-k-个升序链表">合并 K 个升序链表</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">23.
合并 K 个升序链表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>归并排序的思想，每两个合成一个，然后继续合成，直到剩下最后一个。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">ListNode[]</span>} <span class="variable">lists</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">ListNode</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeKLists = <span class="keyword">function</span> (<span class="params">lists</span>) {</span><br><span class="line">  <span class="keyword">if</span> (lists.<span class="property">length</span> === <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mergeList</span>(lists, <span class="number">0</span>, lists.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeList</span>(<span class="params">lists, left, right</span>) {</span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">    <span class="keyword">return</span> lists[left];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> leftList = <span class="title function_">mergeList</span>(lists, left, mid);</span><br><span class="line">  <span class="keyword">let</span> rightList = <span class="title function_">mergeList</span>(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">  <span class="keyword">let</span> tail = dummy;</span><br><span class="line">  <span class="keyword">while</span> (leftList &amp;&amp; rightList) {</span><br><span class="line">    <span class="keyword">if</span> (leftList.<span class="property">val</span> &lt; rightList.<span class="property">val</span>) {</span><br><span class="line">      tail.<span class="property">next</span> = leftList;</span><br><span class="line">      leftList = leftList.<span class="property">next</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      tail.<span class="property">next</span> = rightList;</span><br><span class="line">      rightList = rightList.<span class="property">next</span>;</span><br><span class="line">    }</span><br><span class="line">    tail = tail.<span class="property">next</span>;</span><br><span class="line">  }</span><br><span class="line">  tail.<span class="property">next</span> = leftList ?? rightList;</span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="实现-lru-缓存">实现 LRU 缓存</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&amp;envId=top-100-liked">146.
LRU 缓存 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>最近最少使用缓存，可以使用一个链表保存数据，如果被使用了则放在链表头或者尾，这样一来，链表的某个方向上就是最近的使用频率递减的趋势。同时使用链表移动数据的操作是
O(1)的。</p>
<p>但是查找很耗时，因此可以采用哈希的方式，存储每个 key
对应的链表的节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val, pre, next</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val ?? { <span class="attr">key</span>: <span class="number">0</span>, <span class="attr">value</span>: <span class="number">0</span> };</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pre</span> = pre ?? <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next ?? <span class="literal">null</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">capacity</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">LRUCache</span> = <span class="keyword">function</span> (<span class="params">capacity</span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dummyHead</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dummyTail</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dummyHead</span>.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">dummyTail</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dummyTail</span>.<span class="property">pre</span> = <span class="variable language_">this</span>.<span class="property">dummyHead</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">kv</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">key</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">kv</span>.<span class="title function_">has</span>(key)) {</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> temp = <span class="variable language_">this</span>.<span class="property">kv</span>.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="title function_">removeNode</span>(temp);</span><br><span class="line">  <span class="title function_">addToTail</span>(<span class="variable language_">this</span>.<span class="property">dummyTail</span>, temp);</span><br><span class="line">  <span class="keyword">return</span> temp.<span class="property">val</span>.<span class="property">value</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">void</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">put</span> = <span class="keyword">function</span> (<span class="params">key, value</span>) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">kv</span>.<span class="title function_">has</span>(key)) {</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="variable language_">this</span>.<span class="property">kv</span>.<span class="title function_">get</span>(key);</span><br><span class="line">    temp.<span class="property">val</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="title function_">removeNode</span>(temp);</span><br><span class="line">    <span class="title function_">addToTail</span>(<span class="variable language_">this</span>.<span class="property">dummyTail</span>, temp);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="keyword">new</span> <span class="title class_">ListNode</span>({ key, value });</span><br><span class="line">    <span class="title function_">addToTail</span>(<span class="variable language_">this</span>.<span class="property">dummyTail</span>, temp);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">kv</span>.<span class="title function_">set</span>(key, temp);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">size</span> &lt; <span class="variable language_">this</span>.<span class="property">capacity</span>) {</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">kv</span>.<span class="title function_">delete</span>(<span class="variable language_">this</span>.<span class="property">dummyHead</span>.<span class="property">next</span>.<span class="property">val</span>.<span class="property">key</span>);</span><br><span class="line">      <span class="title function_">removeNode</span>(<span class="variable language_">this</span>.<span class="property">dummyHead</span>.<span class="property">next</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeNode</span>(<span class="params">temp</span>) {</span><br><span class="line">  temp.<span class="property">pre</span>.<span class="property">next</span> = temp.<span class="property">next</span>;</span><br><span class="line">  temp.<span class="property">next</span>.<span class="property">pre</span> = temp.<span class="property">pre</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addToTail</span>(<span class="params">dummyTail, temp</span>) {</span><br><span class="line">  temp.<span class="property">next</span> = dummyTail;</span><br><span class="line">  temp.<span class="property">pre</span> = dummyTail.<span class="property">pre</span>;</span><br><span class="line">  dummyTail.<span class="property">pre</span> = temp;</span><br><span class="line">  temp.<span class="property">pre</span>.<span class="property">next</span> = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new LRUCache(capacity)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"> * obj.put(key,value)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="type">int</span> key, val;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node *prev;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> key, <span class="type">int</span> val) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> key, <span class="type">int</span> val, Node *next, Node *prev) {</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prev = prev;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; hash;</span><br><span class="line">    Node *dummyHead;</span><br><span class="line">    Node *dummyTail;</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) {</span><br><span class="line">        size = capacity;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dummyTail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = dummyTail;</span><br><span class="line">        dummyTail-&gt;prev = dummyHead;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNodeToHead</span><span class="params">(Node *temp)</span> </span>{</span><br><span class="line">        temp-&gt;next = dummyHead-&gt;next;</span><br><span class="line">        temp-&gt;prev = dummyHead;</span><br><span class="line">        dummyHead-&gt;next-&gt;prev = temp;</span><br><span class="line">        dummyHead-&gt;next = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(Node *temp)</span> </span>{</span><br><span class="line">        temp-&gt;prev-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next-&gt;prev = temp-&gt;prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!hash.<span class="built_in">count</span>(key)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">auto</span> temp = hash[key];</span><br><span class="line">        <span class="built_in">removeNode</span>(temp);</span><br><span class="line">        <span class="built_in">addNodeToHead</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(key)) {</span><br><span class="line">            <span class="keyword">auto</span> temp = hash[key];</span><br><span class="line">            temp-&gt;val = value;</span><br><span class="line">            <span class="built_in">removeNode</span>(temp);</span><br><span class="line">            <span class="built_in">addNodeToHead</span>(temp);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">auto</span> temp = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            hash[key] = temp;</span><br><span class="line">            <span class="built_in">addNodeToHead</span>(temp);</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">size</span>() &gt; size) {</span><br><span class="line">                <span class="keyword">auto</span> removed = dummyTail-&gt;prev;</span><br><span class="line">                <span class="built_in">removeNode</span>(removed);</span><br><span class="line">                hash.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="二叉树的层序遍历">二叉树的层序遍历</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">102.
二叉树的层序遍历 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>层序遍历使用队列即可，但是题目中要求每一层的数据单独作为一个子数组保存。</p>
<p>在每次遍历队列之前，可以获取队列的长度，即表示当前层的节点个数。然后一次性遍历当前层所有的节点，下一次遍历的时候，就是遍历的下一层的节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number[][]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span> (<span class="params">root</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!root) {</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> que = [root];</span><br><span class="line">  <span class="keyword">while</span> (que.<span class="property">length</span>) {</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">const</span> size = que.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">      <span class="keyword">const</span> temp = que.<span class="title function_">shift</span>();</span><br><span class="line">      ret.<span class="title function_">push</span>(temp.<span class="property">val</span>);</span><br><span class="line">      <span class="keyword">if</span> (temp.<span class="property">left</span>) {</span><br><span class="line">        que.<span class="title function_">push</span>(temp.<span class="property">left</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (temp.<span class="property">right</span>) {</span><br><span class="line">        que.<span class="title function_">push</span>(temp.<span class="property">right</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    ans.<span class="title function_">push</span>(ret);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="将有序数组转为平衡二叉搜索树">将有序数组转为平衡二叉搜索树</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">108.
将有序数组转换为二叉搜索树 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>要求为平衡二叉树，利用二分查找得到的搜索树是平衡的，可以利用二分查找的思路构造。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">TreeNode</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="keyword">function</span> (<span class="params">nums</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">recur</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recur</span>(<span class="params">nums, left, right</span>) {</span><br><span class="line">  <span class="keyword">if</span> (left === right) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[left]);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">  root.<span class="property">left</span> = <span class="title function_">recur</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">  root.<span class="property">right</span> = <span class="title function_">recur</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="验证是否是二叉搜索树">验证是否是二叉搜索树</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">98.
验证二叉搜索树 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>利用二叉搜索树的性质，中序遍历的结果是有序的。因此可以采用中序遍历，同时使用一个变量保存遍历时上次的结果，<strong>当前值大于上一次的值</strong>并且<strong>左右子树都为二叉搜索树</strong>才为二叉搜索树。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">boolean</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span> (<span class="params">root</span>) {</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">recur</span>(<span class="params">root</span>) {</span><br><span class="line">    <span class="keyword">if</span> (!root) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> leftBST = <span class="title function_">recur</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">const</span> cur = root.<span class="property">val</span>;</span><br><span class="line">    <span class="keyword">if</span> (pre &lt; cur) {</span><br><span class="line">      pre = cur;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> rightBST = <span class="title function_">recur</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> leftBST &amp;&amp; rightBST;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">recur</span>(root);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树第-k-小的元素">二叉搜索树第 K 小的元素</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&amp;envId=top-100-liked">230.
二叉搜索树中第 K 小的元素 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>由二叉搜索树的性质，中序遍历为从小到大的序列，可以采用中序遍历的方式，遍历到第
K 个数的时候记录值，即为第 K 小的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> kthSmallest = <span class="keyword">function</span> (<span class="params">root, k</span>) {</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">recur</span>(<span class="params">root</span>) {</span><br><span class="line">    <span class="keyword">if</span> (!root) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="title function_">recur</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="comment">// 遍历一个之后k减1，当k === 0时说明已经遍历到了，后续就不能再遍历了。</span></span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">1</span>) {</span><br><span class="line">      ans = root.<span class="property">val</span>;</span><br><span class="line">    }</span><br><span class="line">    k--;</span><br><span class="line">    <span class="title function_">recur</span>(root.<span class="property">right</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">recur</span>(root);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的右视图">二叉树的右视图</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&amp;envId=top-100-liked">199.
二叉树的右视图 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>要求每一层的最右边的数据，可以考虑用层序遍历，每一层的最后一个数据为结果集的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number[]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rightSideView = <span class="keyword">function</span> (<span class="params">root</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!root) {</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> que = [];</span><br><span class="line">  que.<span class="title function_">push</span>(root);</span><br><span class="line">  <span class="keyword">while</span> (que.<span class="property">length</span>) {</span><br><span class="line">    <span class="keyword">const</span> size = que.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">      <span class="keyword">const</span> temp = que.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="keyword">if</span> (i === size - <span class="number">1</span>) {</span><br><span class="line">        ans.<span class="title function_">push</span>(temp.<span class="property">val</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 下边两个判断可以用另一种方式写</span></span><br><span class="line">      <span class="comment">// temp.left &amp;&amp; que.push(temp.left)</span></span><br><span class="line">      <span class="comment">// temp.right &amp;&amp; que.push(temp.right)</span></span><br><span class="line">      <span class="keyword">if</span> (temp.<span class="property">left</span>) {</span><br><span class="line">        que.<span class="title function_">push</span>(temp.<span class="property">left</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (temp.<span class="property">right</span>) {</span><br><span class="line">        que.<span class="title function_">push</span>(temp.<span class="property">right</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="二叉树展开为链表">二叉树展开为链表</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">114.
二叉树展开为链表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>按照先序遍历方式展开，左指针始终为
null，而元素都在右指针，考虑按照递归的做法，将左右子树分别展开，然后将左子树的节点（如果有）链接到右子树上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">void</span>} Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="keyword">function</span> (<span class="params">root</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!root) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">flatten</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">flatten</span>(root.<span class="property">right</span>);</span><br><span class="line">  <span class="keyword">let</span> temp = root.<span class="property">left</span>;</span><br><span class="line">  <span class="keyword">if</span> (temp) {</span><br><span class="line">    <span class="comment">// 一直找到展开好的左子树的最后的节点</span></span><br><span class="line">    <span class="keyword">while</span> (temp.<span class="property">right</span>) {</span><br><span class="line">      temp = temp.<span class="property">right</span>;</span><br><span class="line">    }</span><br><span class="line">    temp.<span class="property">right</span> = root.<span class="property">right</span>;</span><br><span class="line">    root.<span class="property">right</span> = root.<span class="property">left</span>;</span><br><span class="line">    root.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>要求使用<code>O(1)</code>的空间复杂度，不使用前序遍历的方式，转换思路。</p>
<p>前序遍历特点为：<strong>根、左、右</strong>，如果要展开成一个链表，则当前节点<code>curr</code>的右子节点，一定排在<code>curr</code>的左子树的某个节点之后。根据特点，可以知道，左子树的最后一个节点一定是左子树（非空）最右侧的节点，因此找到后，可以认为这个最右侧的节点是当前节点的右子节点的前驱结点<code>prev</code>，将<code>prev</code>的右孩子设置为当前节点的右子节点，将当前节点的左子树设置为右孩子（因为左子树一定是当前节点的后驱节点），并将左子树置空。将当前节点向右孩子走一步，完成一轮循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr) {</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;left) {</span><br><span class="line">                <span class="keyword">auto</span> prev = curr-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (prev-&gt;right) {</span><br><span class="line">                    prev = prev-&gt;right;</span><br><span class="line">                }</span><br><span class="line">                prev-&gt;right = curr-&gt;right;</span><br><span class="line">                curr-&gt;right = curr-&gt;left;</span><br><span class="line">                curr-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            }</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="从前序遍历和中序遍历构造二叉树">从前序遍历和中序遍历构造二叉树</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">105.
从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>根据前序遍历特点，最先遍历的肯定是根节点，所以第一个数一定是根节点，然后根据这个根节点，从中序遍历找到对应的位置，那么中序遍历该位置的左边为左子树的节点，右边为右子树的节点，依次递归。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">preorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">inorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">TreeNode</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span> (<span class="params">preorder, inorder</span>) {</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">recur</span>(<span class="params">preorder, preLeft, preRight, inorder, inLeft, inRight</span>) {</span><br><span class="line">    <span class="keyword">if</span> (preLeft &gt; preRight) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preLeft]);</span><br><span class="line">    <span class="keyword">const</span> inIndex = inorder.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item === root.<span class="property">val</span>);</span><br><span class="line">    <span class="keyword">const</span> leftLength = inIndex - inLeft,</span><br><span class="line">      rightLength = inRight - inIndex;</span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">recur</span>(</span><br><span class="line">      preorder,</span><br><span class="line">      preLeft + <span class="number">1</span>,</span><br><span class="line">      preLeft + leftLength,</span><br><span class="line">      inorder,</span><br><span class="line">      inLeft,</span><br><span class="line">      inIndex - <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">recur</span>(</span><br><span class="line">      preorder,</span><br><span class="line">      preLeft + leftLength + <span class="number">1</span>,</span><br><span class="line">      preRight,</span><br><span class="line">      inorder,</span><br><span class="line">      inIndex + <span class="number">1</span>,</span><br><span class="line">      inRight</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">recur</span>(preorder, <span class="number">0</span>, preorder.<span class="property">length</span> - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="路径总和-ⅲ">路径总和 Ⅲ</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/?envType=study-plan-v2&amp;envId=top-100-liked">437.
路径总和 III - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>法一：深度优先搜索，每次计算以<code>root</code>为根节点，向下计算满足<code>targetSum</code>的个数，记为<code>rootSum(root, targetSum)</code>，然后递归遍历每个节点，计算以每个节点为根节点的满足条件的个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">targetSum</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pathSum = <span class="keyword">function</span> (<span class="params">root, targetSum</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!root) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="title function_">rootSum</span>(root, targetSum) +</span><br><span class="line">    <span class="title function_">pathSum</span>(root.<span class="property">left</span>, targetSum) +</span><br><span class="line">    <span class="title function_">pathSum</span>(root.<span class="property">right</span>, targetSum)</span><br><span class="line">  );</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rootSum</span>(<span class="params">root, targetSum</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!root) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="title function_">rootSum</span>(root.<span class="property">left</span>, targetSum - root.<span class="property">val</span>) +</span><br><span class="line">    <span class="title function_">rootSum</span>(root.<span class="property">right</span>, targetSum - root.<span class="property">val</span>) +</span><br><span class="line">    (root.<span class="property">val</span> === targetSum ? <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>法二：前缀和</p>
<p>从<code>root</code>节点到<code>node</code>节点的路径上的和记为前缀和，可以看作是一维的前缀和。</p>
<p>使用前序遍历，遍历过程中记录前缀和，同时记录满足该前缀和的节点个数。</p>
<p>如果<code>root</code>到<code>node</code>之间的节点<code>p</code>满足<code>prefixSum - targetSum</code>，则说明<code>p</code>节点的下一个节点到<code>node</code>节点前缀和为<code>targetSum</code>。</p>
<p>计算完成后恢复，因为计算其他路径的前缀和时可能有相同的前缀和，但是其他路径的会影响当前路径，因此需要删除。参考：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/solutions/596361/dui-qian-zhui-he-jie-fa-de-yi-dian-jie-s-dey6">题解<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">targetSum</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pathSum = <span class="keyword">function</span> (<span class="params">root, targetSum</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!root) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> prefix = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  prefix.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">dfs</span>(root, prefix, <span class="number">0</span>, targetSum);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">root, prefix, curr, targetSum</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!root) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  curr += root.<span class="property">val</span>;</span><br><span class="line">  <span class="keyword">let</span> ret = prefix.<span class="title function_">get</span>(curr - targetSum) ?? <span class="number">0</span>;</span><br><span class="line">  prefix.<span class="title function_">set</span>(curr, (prefix.<span class="title function_">get</span>(curr) ?? <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">  ret += <span class="title function_">dfs</span>(root.<span class="property">left</span>, prefix, curr, targetSum);</span><br><span class="line">  ret += <span class="title function_">dfs</span>(root.<span class="property">right</span>, prefix, curr, targetSum);</span><br><span class="line">  prefix.<span class="title function_">set</span>(curr, prefix.<span class="title function_">get</span>(curr) - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最近公共祖先">二叉树的最近公共祖先</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">236.
二叉树的最近公共祖先 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) {</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">TreeNode</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span> (<span class="params">root, p, q</span>) {</span><br><span class="line">  <span class="keyword">if</span> (!root || root === p || root === q) {</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> left = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">left</span>, p, q);</span><br><span class="line">  <span class="keyword">const</span> right = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">right</span>, p, q);</span><br><span class="line">  <span class="keyword">if</span> (!left) {</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (!right) {</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="二叉树中的最大路径和">二叉树中的最大路径和</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&amp;envId=top-100-liked">124.
二叉树中的最大路径和 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>采用递归的方式，设置<code>maxGain(root)</code>函数，表示从从<code>root</code>节点上能获得的最大贡献值，贡献值表示为从<code>root</code>节点向左子树或者右子树延申（只能是<code>root</code>的左子树或者右子树一个方向），得到的最大的值，以此类推，<code>roo.left</code>的最大贡献值表示为<code>root.left</code>向左子树或者右子树延申。这是一个递归的过程。</p>
<p>可以在递归的时候求出最大的路径和。当左子树和右子树的最大贡献值大于 0
的时候，才能算作贡献去计算路径和，否则还不如直接使用根节点当作单独的路径和大。最后返回贡献值，选择左右子树最大的作为贡献值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) {</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">TreeNode</span>} <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxPathSum = <span class="keyword">function</span> (<span class="params">root</span>) {</span><br><span class="line">  <span class="keyword">let</span> maxSum = -<span class="title class_">Infinity</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">maxGain</span>(<span class="params">root</span>) {</span><br><span class="line">    <span class="keyword">if</span> (!root) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">const</span> leftGain = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">maxGain</span>(root.<span class="property">left</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> rightGain = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">maxGain</span>(root.<span class="property">right</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> temp = root.<span class="property">val</span> + leftGain + rightGain;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(maxSum);</span><br><span class="line">    maxSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxSum, temp);</span><br><span class="line">    <span class="keyword">return</span> root.<span class="property">val</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(leftGain, rightGain);</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">maxGain</span>(root);</span><br><span class="line">  <span class="keyword">return</span> maxSum;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="岛屿数量">岛屿数量</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&amp;envId=top-100-liked">200.
岛屿数量 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>使用深度优先遍历，遇到<code>1</code>后进行深度优先遍历，将遍历到的所有<code>1</code>进行标记，组成岛屿。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">character[][]</span>} <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numIslands = <span class="keyword">function</span> (<span class="params">grid</span>) {</span><br><span class="line">  <span class="keyword">const</span> m = grid.<span class="property">length</span>,</span><br><span class="line">    n = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">  <span class="keyword">const</span> dx = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">    dy = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">grid, x, y</span>) {</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dx.<span class="property">length</span>; i++) {</span><br><span class="line">      <span class="keyword">const</span> nx = x + dx[i],</span><br><span class="line">        ny = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        nx &lt; <span class="number">0</span> ||</span><br><span class="line">        ny &lt; <span class="number">0</span> ||</span><br><span class="line">        nx &gt;= m ||</span><br><span class="line">        ny &gt;= n ||</span><br><span class="line">        grid[nx][ny] === <span class="string">'0'</span> ||</span><br><span class="line">        visited[nx][ny]</span><br><span class="line">      ) {</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="title function_">dfs</span>(grid, nx, ny);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="property">length</span>; j++) {</span><br><span class="line">      <span class="comment">// 遍历每一个元素，当为1且没有被访问时，说明会组成一个新的岛屿，结果+1</span></span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="string">'1'</span> &amp;&amp; !visited[i][j]) {</span><br><span class="line">        <span class="title function_">dfs</span>(grid, i, j);</span><br><span class="line">        ans++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="腐烂的橘子">腐烂的橘子</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/?envType=study-plan-v2&amp;envId=top-100-liked">994.
腐烂的橘子 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>多源的宽度优先搜索，因为可能同时存在多个腐烂的橘子，是同时扩散的。</p>
<p>初始时找到所有腐烂的橘子加入队列，作为初始的多个起点，然后遍历，同时这里使用了<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">102.
二叉树的层序遍历 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a>的方法，每一次遍历“一层”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[][]</span>} <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> orangesRotting = <span class="keyword">function</span> (<span class="params">grid</span>) {</span><br><span class="line">  <span class="keyword">const</span> m = grid.<span class="property">length</span>,</span><br><span class="line">    n = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> que = [];</span><br><span class="line">  <span class="comment">// 保存所有好的橘子</span></span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="property">length</span>; j++) {</span><br><span class="line">      grid[i][j] === <span class="number">2</span> &amp;&amp; que.<span class="title function_">push</span>([i, j]);</span><br><span class="line">      grid[i][j] === <span class="number">1</span> &amp;&amp; cnt++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> dx = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">    dy = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 没有遍历完并且还有好的橘子，说明可以继续腐烂，否则，不再继续遍历。</span></span><br><span class="line">  <span class="keyword">while</span> (que.<span class="property">length</span> &amp;&amp; cnt) {</span><br><span class="line">    ans++;</span><br><span class="line">    <span class="keyword">let</span> size = que.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (size--) {</span><br><span class="line">      <span class="keyword">const</span> [x, y] = que.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dx.<span class="property">length</span>; i++) {</span><br><span class="line">        <span class="keyword">const</span> nx = x + dx[i],</span><br><span class="line">          ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= m || ny &gt;= n || grid[nx][ny] !== <span class="number">1</span>) {</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 腐烂后则减1</span></span><br><span class="line">        cnt--;</span><br><span class="line">        grid[nx][ny] = <span class="number">2</span>;</span><br><span class="line">        que.<span class="title function_">push</span>([nx, ny]);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果还有好的橘子，说明不可能</span></span><br><span class="line">  <span class="keyword">return</span> cnt === <span class="number">0</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="课程表">课程表</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&amp;envId=top-100-liked">207.
课程表 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>拓扑排序，首先是图的构造，使用二维数组表示，<code>graph[i] = [a, b, c]</code>表示<code>i</code>指向<code>a, b, c</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">numCourses</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[][]</span>} <span class="variable">prerequisites</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">boolean</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canFinish = <span class="keyword">function</span> (<span class="params">numCourses, prerequisites</span>) {</span><br><span class="line">  <span class="keyword">const</span> graph = <span class="keyword">new</span> <span class="title class_">Array</span>(numCourses).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> []);</span><br><span class="line">  <span class="keyword">const</span> indegree = <span class="keyword">new</span> <span class="title class_">Array</span>(numCourses).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [a, b] <span class="keyword">of</span> prerequisites) {</span><br><span class="line">    graph[b].<span class="title function_">push</span>(a);</span><br><span class="line">    indegree[a]++;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> que = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">    indegree[i] === <span class="number">0</span> &amp;&amp; que.<span class="title function_">push</span>(i);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">while</span> (que.<span class="property">length</span>) {</span><br><span class="line">    <span class="keyword">const</span> i = que.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> j <span class="keyword">of</span> graph[i]) {</span><br><span class="line">      indegree[j]--;</span><br><span class="line">      indegree[j] === <span class="number">0</span> &amp;&amp; que.<span class="title function_">push</span>(j);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">    <span class="keyword">if</span> (indegree[i] !== <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="实现-trie-树">实现 Trie 树</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">208.
实现 Trie (前缀树) - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>每个节点（假设）有 26
个子树（根据字符集决定），每个边表示一个字符，如果有这个边，表示存在，没有边表示不存在。</p>
<p>如果需要判断每个单词出现了多少次，或者是以某个单词为前缀的单词有多少个，可以增加变量
<code>end: int, pass: int</code>用数量表示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Trie</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">end</span> = <span class="literal">false</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">string</span>} <span class="variable">word</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">void</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">insert</span> = <span class="keyword">function</span> (<span class="params">word</span>) {</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">const</span> c = word[i];</span><br><span class="line">    <span class="comment">// 原来不存在才创建，否则会丢失原有的数据</span></span><br><span class="line">    <span class="keyword">if</span> (!temp.<span class="property">next</span>.<span class="title function_">get</span>(c)) {</span><br><span class="line">      temp.<span class="property">next</span>.<span class="title function_">set</span>(c, <span class="keyword">new</span> <span class="title class_">Trie</span>());</span><br><span class="line">    }</span><br><span class="line">    temp = temp.<span class="property">next</span>.<span class="title function_">get</span>(c);</span><br><span class="line">  }</span><br><span class="line">  temp.<span class="property">end</span> = <span class="literal">true</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">string</span>} <span class="variable">word</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">boolean</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">search</span> = <span class="keyword">function</span> (<span class="params">word</span>) {</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> word) {</span><br><span class="line">    <span class="comment">// 获取下一个节点</span></span><br><span class="line">    <span class="keyword">const</span> node = temp.<span class="property">next</span>.<span class="title function_">get</span>(c);</span><br><span class="line">    <span class="comment">// 如果没有则说明没有添加过</span></span><br><span class="line">    <span class="keyword">if</span> (!node) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    temp = node;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果end为true说明添加的是这个单词，否则只能说明以这个单词为前缀</span></span><br><span class="line">  <span class="keyword">return</span> temp.<span class="property">end</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">string</span>} <span class="variable">prefix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">boolean</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">startsWith</span> = <span class="keyword">function</span> (<span class="params">prefix</span>) {</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> prefix) {</span><br><span class="line">    <span class="keyword">const</span> node = temp.<span class="property">next</span>.<span class="title function_">get</span>(c);</span><br><span class="line">    <span class="keyword">if</span> (!node) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    temp = node;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new Trie()</span></span><br><span class="line"><span class="comment"> * obj.insert(word)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.startsWith(prefix)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="全排列">全排列</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&amp;envId=top-100-liked">46.
全排列 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>题目中限定了没有重复的元素，递归时无需特判。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number[][]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span> (<span class="params">nums</span>) {</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">nums, k</span>) {</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === k) {</span><br><span class="line">      ans.<span class="title function_">push</span>(nums.<span class="title function_">slice</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = k; i &lt; nums.<span class="property">length</span>; i++) {</span><br><span class="line">      <span class="comment">// 交换当前位置和第i个位置的元素</span></span><br><span class="line">      [nums[i], nums[k]] = [nums[k], nums[i]];</span><br><span class="line">      <span class="title function_">dfs</span>(nums, k + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 复位</span></span><br><span class="line">      [nums[i], nums[k]] = [nums[k], nums[i]];</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="子集">子集</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&amp;envId=top-100-liked">78.
子集 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>求子集，核心思想可以用二进制考虑，每一个元素都有“要”或者“不要”两种选择，可以采用递归的方式，也可以采用迭代使用二进制方式，二进制的某位为
1 时表示要，0 表示不要。</p>
<p>使用回溯方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number[][]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span> (<span class="params">nums</span>) {</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">k, ret</span>) {</span><br><span class="line">    <span class="keyword">if</span> (k === nums.<span class="property">length</span>) {</span><br><span class="line">      ans.<span class="title function_">push</span>(ret.<span class="title function_">slice</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="title function_">dfs</span>(k + <span class="number">1</span>, ret);</span><br><span class="line">    ret.<span class="title function_">push</span>(nums[k]);</span><br><span class="line">    <span class="title function_">dfs</span>(k + <span class="number">1</span>, ret);</span><br><span class="line">    <span class="comment">// 归位，</span></span><br><span class="line">    ret.<span class="title function_">pop</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">dfs</span>(<span class="number">0</span>, []);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>使用二进制方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number[][]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span> (<span class="params">nums</span>) {</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; nums.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.<span class="property">length</span>; j++) {</span><br><span class="line">      <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) {</span><br><span class="line">        ret.<span class="title function_">push</span>(nums[j]);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    ans.<span class="title function_">push</span>(ret);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="电话号码的字母组合">电话号码的字母组合</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/?envType=study-plan-v2&amp;envId=top-100-liked">17.
电话号码的字母组合 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>也是一种组合问题，但是较为简单，给定一个一组数字字符串，按照这个顺序打出来的字母组合有哪些，因为数字顺序时固定的，可以每次从当前数字中挑一个对应的字母添加到结果末尾，然后选择下一个数字的字母，依次类推。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">string</span>} <span class="variable">digits</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">string[]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="keyword">function</span> (<span class="params">digits</span>) {</span><br><span class="line">  <span class="keyword">if</span> (digits.<span class="property">length</span> === <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> numDigit = {</span><br><span class="line">    <span class="number">2</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">    <span class="number">5</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">    <span class="number">6</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">    <span class="number">7</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">    <span class="number">8</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">    <span class="number">9</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>],</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">k, ret</span>) {</span><br><span class="line">    <span class="keyword">if</span> (k === digits.<span class="property">length</span>) {</span><br><span class="line">      ans.<span class="title function_">push</span>(ret);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> numDigit[digits[k]]) {</span><br><span class="line">      <span class="title function_">dfs</span>(k + <span class="number">1</span>, ret.<span class="title function_">concat</span>(c));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">dfs</span>(<span class="number">0</span>, <span class="string">''</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="组合总和">组合总和</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">39.
组合总和 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>难点在于结果集不能重复，如<code>[2, 2, 3]</code>和<code>[2, 3, 2]</code>是重复的。因此在
dfs
时需要主动避免产生重复的结果。做法：每次搜索时设置下一次搜索的起点，避免后续的搜索会搜索前边搜索过的结果。</p>
<p>具体可参考：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/solutions/14697/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/?envType=study-plan-v2&amp;envId=top-100-liked">39.
组合总和 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">candidates</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number[][]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum = <span class="keyword">function</span> (<span class="params">candidates, target</span>) {</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="comment">// idx表示这一轮搜索的起始位置</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">ret, sum, idx</span>) {</span><br><span class="line">    <span class="keyword">if</span> (idx === candidates.<span class="property">length</span>) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (sum === target) {</span><br><span class="line">      ans.<span class="title function_">push</span>(ret.<span class="title function_">slice</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 此轮搜索不要当前值，则下一轮搜索需要从下一个位置开始</span></span><br><span class="line">    <span class="title function_">dfs</span>(ret, sum, idx + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum + candidates[idx] &lt;= target) {</span><br><span class="line">      ret.<span class="title function_">push</span>(candidates[idx]);</span><br><span class="line">      <span class="comment">// 此轮搜索要当前值，下一轮搜索也从当前位置开始</span></span><br><span class="line">      <span class="title function_">dfs</span>(ret, sum + candidates[idx], idx);</span><br><span class="line">      ret.<span class="title function_">pop</span>();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">dfs</span>([], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="括号生成">括号生成</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&amp;envId=top-100-liked">22.
括号生成 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>多种方法可以做，这里先采取回溯法做。</p>
<p>回溯的前提是使用深度优先搜索，然后使用剪枝策略优化。因此首先想到使用深搜搜索出所有的结果。画出递归树：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/10356726/1724765611931-bb0ccd90-8111-4e04-89aa-d1d4937ead50.png"></p>
<p>通过递归树可以看到，有些结果是不能要的，比如<code>((((</code>、<code>))))</code>等等，因此，在进行深搜时需要加上判断条件进行剪枝。</p>
<p>如果括号能匹配，首先<strong>左括号的个数不能超过</strong><code>n</code>，因为这里是从前往后追加括号，因此左括号的个数优先增大，而且，如果想要后续的右括号可以匹配上左括号，<strong>左括号的个数一定要大于或等于右括号</strong>，否则像<code>(()))</code>，后续无论怎么追加括号，都不是合法的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">string[]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="keyword">function</span> (<span class="params">n</span>) {</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">left, right</span>) {</span><br><span class="line">    <span class="keyword">if</span> (left &gt; n || left &lt; right) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">length</span> === <span class="number">2</span> * n) {</span><br><span class="line">      ans.<span class="title function_">push</span>(path.<span class="title function_">join</span>(<span class="string">''</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    path.<span class="title function_">push</span>(<span class="string">'('</span>);</span><br><span class="line">    <span class="title function_">dfs</span>(left + <span class="number">1</span>, right);</span><br><span class="line">    path.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    path.<span class="title function_">push</span>(<span class="string">')'</span>);</span><br><span class="line">    <span class="title function_">dfs</span>(left, right + <span class="number">1</span>);</span><br><span class="line">    path.<span class="title function_">pop</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="单词搜索">单词搜索</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/?envType=study-plan-v2&amp;envId=top-100-liked">79.
单词搜索 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>此题需要用回溯才能达到最佳，因此要考虑剪枝策略。</p>
<p>首先按照深搜的方式，从某个点出发，遍历所有方向所有长度的字符串，直到找到符合条件的。</p>
<p>可以想到一个剪枝策略，当下一个字符和要查找的字符串的下一个字符匹配时才进行搜索，如果不匹配，即使搜索了，也是不满足的。</p>
<p>还有一个注意点，停止条件是：遍历到<code>word</code>字符串的最后一个位置时就要终止递归了。</p>
<p>因为<code>dfs(i, j, idx)</code>表示的是：<code>board[i, j]</code>位置的字符和<code>word[idx]</code>位置的字符相同，只有当相同的时候才会走进这个递归。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">character[][]</span>} <span class="variable">board</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">string</span>} <span class="variable">word</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">boolean</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> exist = <span class="keyword">function</span> (<span class="params">board, word</span>) {</span><br><span class="line">  <span class="keyword">const</span> m = board.<span class="property">length</span>,</span><br><span class="line">    n = board[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">  <span class="keyword">const</span> dx = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">    dy = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">x, y, idx</span>) {</span><br><span class="line">    <span class="keyword">if</span> (idx === word.<span class="property">length</span> - <span class="number">1</span>) {</span><br><span class="line">      ans = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (ans) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">      <span class="keyword">const</span> nx = x + dx[i],</span><br><span class="line">        ny = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        nx &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        nx &lt; m &amp;&amp;</span><br><span class="line">        ny &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ny &lt; n &amp;&amp;</span><br><span class="line">        !visited[nx][ny] &amp;&amp;</span><br><span class="line">        board[nx][ny] == word[idx + <span class="number">1</span>]</span><br><span class="line">      ) {</span><br><span class="line">        visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">dfs</span>(nx, ny, idx + <span class="number">1</span>);</span><br><span class="line">        visited[nx][ny] = <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    visited[x][y] = <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; board.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; board[i].<span class="property">length</span>; j++) {</span><br><span class="line">      board[i][j] === word[<span class="number">0</span>] &amp;&amp; <span class="title function_">dfs</span>(i, j, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="分割回文串">分割回文串</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&amp;envId=top-100-liked">131.
分割回文串 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>用到了两种算法，一种是动态规划，一种是回溯。</p>
<p>回溯用于搜索到所有可能的子串，然后通过动态规划判断是否可以组成回文串。</p>
<p>使用一个下标<code>i</code>表示当前搜索到的位置，<code>[0, i - 1]</code>表示已经搜索过的，<code>[i, n]</code>表示没有搜索的，然后对<code>[i, j]</code>进行判断，如果可以构成回文串，则从<code>j + 1</code>开始进行下一次搜索。</p>
<p>动态规划主要用于快速判断是否是回文串，这里采用记忆化搜索的方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">string</span>} <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">string[][]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="keyword">function</span> (<span class="params">s</span>) {</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">null</span>));</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">i, ret</span>) {</span><br><span class="line">    <span class="keyword">if</span> (i === s.<span class="property">length</span>) {</span><br><span class="line">      ans.<span class="title function_">push</span>(ret.<span class="title function_">slice</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; s.<span class="property">length</span>; j++) {</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">dp</span>(i, j)) {</span><br><span class="line">        ret.<span class="title function_">push</span>(s.<span class="title function_">slice</span>(i, j + <span class="number">1</span>));</span><br><span class="line">        <span class="title function_">dfs</span>(j + <span class="number">1</span>, ret);</span><br><span class="line">        ret.<span class="title function_">pop</span>();</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 记忆化搜索的方式</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dp</span>(<span class="params">x, y</span>) {</span><br><span class="line">    <span class="keyword">if</span> (f[x][y] !== <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> f[x][y];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = x, j = y; i &lt; j; i++, j--) {</span><br><span class="line">      <span class="keyword">if</span> (s[i] !== s[j]) {</span><br><span class="line">        f[x][y] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    f[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">dfs</span>(<span class="number">0</span>, []);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="n-皇后">N 皇后</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&amp;envId=top-100-liked">51.
N 皇后 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>难点在于怎么快速判断当前位置是否是可放的位置，即判断当前位置的行、列和两个对角线是否有其他皇后。</p>
<p>其中表示两个对角线是最难的。</p>
<p>可以将行和列看作是<strong>坐标系</strong>，将对角线平移的时候，和<code>y</code>轴的交点即为在数组中的下标，需要注意的是另一种情况下标会出现负数，因此可以将整体加上<code>n - 1</code>保证为正数，或者也可以使用哈希表存储不用考虑正负问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">string[][]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solveNQueens = <span class="keyword">function</span> (<span class="params">n</span>) {</span><br><span class="line">  <span class="keyword">const</span> row = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>),</span><br><span class="line">    col = row.<span class="title function_">slice</span>();</span><br><span class="line">  <span class="keyword">const</span> diag = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span> * n - <span class="number">1</span>),</span><br><span class="line">    rediag = diag.<span class="title function_">slice</span>();</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> place = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="string">'.'</span>));</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">idx</span>) {</span><br><span class="line">    <span class="keyword">if</span> (idx === n) {</span><br><span class="line">      ans.<span class="title function_">push</span>(place.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="title function_">join</span>(<span class="string">''</span>)));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">check</span>(idx, i)) {</span><br><span class="line">        row[idx] = col[i] = diag[idx + i] = rediag[idx - i + n - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        place[idx][i] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="title function_">dfs</span>(idx + <span class="number">1</span>);</span><br><span class="line">        place[idx][i] = <span class="string">'.'</span>;</span><br><span class="line">        row[idx] = col[i] = diag[idx + i] = rediag[idx - i + n - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">idx, i</span>) {</span><br><span class="line">    <span class="keyword">return</span> !(row[idx] || col[i] || diag[idx + i] || rediag[idx - i + n - <span class="number">1</span>]);</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_">dfs</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="搜索插入位置">搜索插入位置</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&amp;envId=top-100-liked">35.
搜索插入位置 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>二分查找的题，记住这个二分经典模板即可。</p>
<p>二分经典模板即可解决这道题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchInsert = <span class="keyword">function</span> (<span class="params">nums, target</span>) {</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">    <span class="keyword">const</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) {</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) {</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="搜索二维矩阵">搜索二维矩阵</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked">74.
搜索二维矩阵 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>二维矩阵的搜索，从二分角度考虑，要寻找中间值，从题目中的排序规律可以看到，<strong>右上角</strong>的值处于中间位置，向左减小，向下增大。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[][]</span>} <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">boolean</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchMatrix = <span class="keyword">function</span> (<span class="params">matrix, target</span>) {</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">0</span>,</span><br><span class="line">    y = matrix[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &lt; matrix.<span class="property">length</span> &amp;&amp; y &gt;= <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">if</span> (matrix[x][y] === target) {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &gt; target) {</span><br><span class="line">      y--;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      x++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="排序数组中查找第一个和最后一个位置">排序数组中查找第一个和最后一个位置</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">34.
在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>模板返回<strong>大于等于</strong>某个值的最小下标、<strong>小于等于</strong>某个值的最大下标。</p>
<p>结果需要注意特殊情况，如果<strong>大于等于</strong>的时候，当返回的结果是<code>nums.length</code>时，表示数组为空或者所有的值都<code>小于target</code>。如果<strong>小于等于</strong>的时候，返回的结果是<code>-1</code>时，表示数组为空或者所有的值都<code>大于target</code>。</p>
<p>当大于等于的时候最终的<code>left</code>为结果，小于等于的时候最终的<code>right</code>为结果。</p>
<p>只记住<strong>大于等于</strong>的模板即可，反过来的可以类比一下推出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number[]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchRange = <span class="keyword">function</span> (<span class="params">nums, target</span>) {</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">biSearch</span>(<span class="params">nums, target, type</span>) {</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">      right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意这里是left &lt;= right</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">      <span class="keyword">const</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) {</span><br><span class="line">          right = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          left = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) {</span><br><span class="line">          left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          right = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> type === <span class="number">0</span> ? left : right;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> start = <span class="title function_">biSearch</span>(nums, target, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 注意特殊情况处理。</span></span><br><span class="line">  <span class="keyword">if</span> (start === nums.<span class="property">length</span> || nums[start] !== target) {</span><br><span class="line">    <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> end = <span class="title function_">biSearch</span>(nums, target, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> [start, end];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="搜索旋转排序数组">搜索旋转排序数组</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">33.
搜索旋转排序数组 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span> (<span class="params">nums, target</span>) {</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 注意是left &lt;= right</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">    <span class="keyword">const</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) {</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// [left, mid]区间部分为非降序的</span></span><br><span class="line">    <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) {</span><br><span class="line">      <span class="comment">// 这里判断target在[left, mid)这个区间中，右开因为上一步判断了不相等</span></span><br><span class="line">      <span class="comment">// 左开因为target和nums[left]可能相等，</span></span><br><span class="line">      <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) {</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// [mid, right]区间部分为非降序的</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) {</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="寻找旋转排序数组中的最小值">寻找旋转排序数组中的最小值</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&amp;envId=top-100-liked">153.
寻找旋转排序数组中的最小值 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>题目中给定的数组和上一题一样，依然是使用二分，这里和最后一个值进行比较，因为旋转后的最后一个值，是第二段区间的最大值，第一段区间的最小值。</p>
<p><strong>注意返回的是</strong><code>**left**</code><strong>，可以按照“返回没有等号的那个被赋值的变量”，如</strong><code>**nums[mid] &gt; nums[nums.length - 1]**</code><strong>条件中没有</strong><code>**=**</code><strong>，则返回</strong><code>**left**</code><strong>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMin = <span class="keyword">function</span> (<span class="params">nums</span>) {</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">    <span class="keyword">const</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; nums[nums.<span class="property">length</span> - <span class="number">1</span>]) {</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> nums[left];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="寻找两个正序数组的中位数">寻找两个正序数组的中位数</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&amp;envId=top-100-liked">4.
寻找两个正序数组的中位数 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>要求<code>O(log(m + 1))</code>的复杂度，可以将问题转化为，两个正序数组中，寻找第<code>k</code>小的数，最多寻找两次即可寻找到两个中位数的位置。</p>
<p>具体可参考题解：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/?envType=study-plan-v2&amp;envId=top-100-liked">4.
寻找两个正序数组的中位数 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="keyword">function</span> (<span class="params">nums1, nums2</span>) {</span><br><span class="line">  <span class="keyword">const</span> sumLen = nums1.<span class="property">length</span> + nums2.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">findKthSmallest</span>(<span class="params">nums1, start1, end1, nums2, start2, end2, k</span>) {</span><br><span class="line">    <span class="keyword">const</span> len1 = end1 - start1 + <span class="number">1</span>,</span><br><span class="line">      len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> <span class="title function_">findKthSmallest</span>(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">    <span class="keyword">if</span> (len1 === <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">1</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(nums1[start1], nums2[start2]);</span><br><span class="line">    <span class="keyword">const</span> i = start1 + <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>), len1) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> j = start2 + <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>), len2) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">findKthSmallest</span>(</span><br><span class="line">        nums1,</span><br><span class="line">        i + <span class="number">1</span>,</span><br><span class="line">        end1,</span><br><span class="line">        nums2,</span><br><span class="line">        start2,</span><br><span class="line">        end2,</span><br><span class="line">        k - (i - start1 + <span class="number">1</span>)</span><br><span class="line">      );</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">findKthSmallest</span>(</span><br><span class="line">        nums1,</span><br><span class="line">        start1,</span><br><span class="line">        end1,</span><br><span class="line">        nums2,</span><br><span class="line">        j + <span class="number">1</span>,</span><br><span class="line">        end2,</span><br><span class="line">        k - (j - start2 + <span class="number">1</span>)</span><br><span class="line">      );</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (sumLen % <span class="number">2</span> === <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      (<span class="title function_">findKthSmallest</span>(</span><br><span class="line">        nums1,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        nums1.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">        nums2,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        nums2.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">        <span class="title class_">Math</span>.<span class="title function_">ceil</span>(sumLen / <span class="number">2</span>)</span><br><span class="line">      ) +</span><br><span class="line">        <span class="title function_">findKthSmallest</span>(</span><br><span class="line">          nums1,</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          nums1.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">          nums2,</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          nums2.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">          <span class="title class_">Math</span>.<span class="title function_">ceil</span>(sumLen / <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">        )) /</span><br><span class="line">      <span class="number">2</span></span><br><span class="line">    );</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">findKthSmallest</span>(</span><br><span class="line">      nums1,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      nums1.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">      nums2,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      nums2.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">ceil</span>(sumLen / <span class="number">2</span>)</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="最小栈">最小栈</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&amp;envId=top-100-liked">155.
最小栈 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>方法一：使用辅助栈</p>
<p>每次入栈时，使用另一个栈保存当前栈里的最小值，同步出入栈，会有额外的空间。</p>
<p>🍕 方法二：不适用额外空间，栈里保存的是每次入栈的值和最小值的差。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MinStack</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stk</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">minValue</span> = -<span class="title class_">Infinity</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">void</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">val</span>) {</span><br><span class="line">  <span class="comment">// 初始没有数据，直接插入</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">stk</span>.<span class="property">length</span>) {</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stk</span>.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minValue</span> = val;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 有数据后，首先取差值diff，然后栈里插入diff</span></span><br><span class="line">  <span class="comment">// 如果diff为正，则说明插入值大，最小值不变，否则说明有更小的，更新最小值</span></span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">const</span> diff = val - <span class="variable language_">this</span>.<span class="property">minValue</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stk</span>.<span class="title function_">push</span>(diff);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minValue</span> = diff &gt; <span class="number">0</span> ? <span class="variable language_">this</span>.<span class="property">minValue</span> : val;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">void</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">stk</span>.<span class="property">length</span>) {</span><br><span class="line">    <span class="keyword">const</span> diff = <span class="variable language_">this</span>.<span class="property">stk</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="comment">// 如果差值大于0，说明插入这一个数时，没有更新最小值，由于diff = val - minValue</span></span><br><span class="line">    <span class="comment">// 所以反推出val = diff + minValue</span></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">const</span> top = diff + <span class="variable language_">this</span>.<span class="property">minValue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果不大于0，说明插入时更新了最小值，最小值即为真实值，所以直接取最小值</span></span><br><span class="line">    <span class="comment">// 因为最小值更新了，所以更新回来，diff = val - minValue反推</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">const</span> top = <span class="variable language_">this</span>.<span class="property">minValue</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">minValue</span> = top - diff;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="comment">// 同理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">stk</span>.<span class="property">length</span>) {</span><br><span class="line">    <span class="keyword">const</span> diff = <span class="variable language_">this</span>.<span class="property">stk</span>.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> diff &gt; <span class="number">0</span> ? diff + <span class="variable language_">this</span>.<span class="property">minValue</span> : <span class="variable language_">this</span>.<span class="property">minValue</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMin</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">minValue</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(val)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.getMin()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串解码">字符串解码</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&amp;envId=top-100-liked">394.
字符串解码 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="方法-1">方法 1</h2>
<p>根据规则，可以看作是一个递归的过程，递归调用。</p>
<p>用栈是为了匹配括号，首先匹配到最外层的括号，然后对括号内的字符串进行递归调用解码。</p>
<p>需要注意：数字和括号的前后都可能存在不需要解码的字符串，仍然需要拼接到结果中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">string</span>} <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">string</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> decodeString = <span class="keyword">function</span> (<span class="params">s</span>) {</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> stk = [];</span><br><span class="line">  <span class="comment">// 记录需要解码的字符串的其实位置，主要用于拼接前半部分不用解码的字符串</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">'['</span>) {</span><br><span class="line">      stk.<span class="title function_">push</span>(i);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">']'</span>) {</span><br><span class="line">      <span class="keyword">if</span> (stk.<span class="property">length</span> === <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">const</span> idx = stk.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">let</span> j = idx - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="string">'0'</span> &lt;= s[j] &amp;&amp; s[j] &lt;= <span class="string">'9'</span>) j--;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">const</span> cnt = <span class="title class_">Number</span>(s.<span class="title function_">slice</span>(j, idx));</span><br><span class="line">        ans = ans</span><br><span class="line">          .<span class="title function_">concat</span>(s.<span class="title function_">slice</span>(start, j))</span><br><span class="line">          .<span class="title function_">concat</span>(<span class="title function_">decodeString</span>(s.<span class="title function_">slice</span>(idx + <span class="number">1</span>, i)).<span class="title function_">repeat</span>(cnt));</span><br><span class="line">        start = i + <span class="number">1</span>;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        stk.<span class="title function_">pop</span>();</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果没有到最后s.length，说明最后的字符串为不用解码的</span></span><br><span class="line">  <span class="keyword">if</span> (start !== s.<span class="property">length</span>) {</span><br><span class="line">    ans = ans.<span class="title function_">concat</span>(s.<span class="title function_">slice</span>(start));</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans || s;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="方法-2">方法 2</h2>
<p>按顺序依次遍历，栈中存储要循环的次数以及<strong>当前循环之前</strong>的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decodeString = <span class="keyword">function</span> (<span class="params">s</span>) {</span><br><span class="line">  <span class="keyword">const</span> arr = [...s];</span><br><span class="line">  <span class="keyword">let</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> stk = [];</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt;= <span class="string">'9'</span> &amp;&amp; arr[i] &gt;= <span class="string">'0'</span>) {</span><br><span class="line">      cnt = cnt * <span class="number">10</span> + <span class="title class_">Number</span>(arr[i]);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] === <span class="string">'['</span>) {</span><br><span class="line">      stk.<span class="title function_">push</span>([cnt, ans.<span class="title function_">slice</span>()]);</span><br><span class="line">      cnt = <span class="number">0</span>;</span><br><span class="line">      ans = [];</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] === <span class="string">']'</span>) {</span><br><span class="line">      <span class="keyword">const</span> [multi, ret] = stk.<span class="title function_">pop</span>();</span><br><span class="line">      ret.<span class="title function_">push</span>(...[...ans.<span class="title function_">join</span>(<span class="string">''</span>).<span class="title function_">repeat</span>(multi)]);</span><br><span class="line">      ans = ret;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      ans.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans.<span class="title function_">join</span>(<span class="string">''</span>);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="每日温度">每日温度</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&amp;envId=top-100-liked">739.
每日温度 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>使用<strong>单调栈，</strong>栈底到栈顶元素依次递减。只要元素在栈中，就说明目前没有发现后续有比该元素大的。</p>
<p>栈里存储的是元素下标，方便计算差了多少天。</p>
<p>如果栈空，直接入栈</p>
<p>否则，如果元素比栈顶元素大，说明栈顶元素后的第一个大的就是当前元素，取出来，计算差值。</p>
<p>否则，跳过直接加入到栈中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">temperatures</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number[]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="keyword">function</span> (<span class="params">temperatures</span>) {</span><br><span class="line">  <span class="keyword">const</span> stk = [],</span><br><span class="line">    ans = <span class="keyword">new</span> <span class="title class_">Array</span>(temperatures.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">while</span> (stk.<span class="property">length</span> &amp;&amp; temperatures[stk.<span class="title function_">at</span>(-<span class="number">1</span>)] &lt; temperatures[i]) {</span><br><span class="line">      <span class="keyword">const</span> t = stk.<span class="title function_">pop</span>();</span><br><span class="line">      ans[t] = i - t;</span><br><span class="line">    }</span><br><span class="line">    stk.<span class="title function_">push</span>(i);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="数组中第-k-个最大的元素">数组中第 K 个最大的元素</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">215.
数组中的第 K 个最大元素 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>要求用<code>O(n)</code>的复杂度，数学证明<strong>快速选择</strong>算法为<code>O(n)</code>复杂度，因此直接使用即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span> (<span class="params">nums, k</span>) {</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">quickChoice</span>(<span class="params">nums, left, right, k</span>) {</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> nums[left];</span><br><span class="line">    <span class="keyword">let</span> less = left - <span class="number">1</span>,</span><br><span class="line">      i = left,</span><br><span class="line">      more = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> x = nums[<span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>)];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; more) {</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &lt; x) {</span><br><span class="line">        less++;</span><br><span class="line">        [nums[i], nums[less]] = [nums[less], nums[i]];</span><br><span class="line">        i++;</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; x) {</span><br><span class="line">        more--;</span><br><span class="line">        [nums[i], nums[more]] = [nums[more], nums[i]];</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        i++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (less &lt; k &amp;&amp; k &lt; more) <span class="keyword">return</span> nums[k];</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= less) <span class="keyword">return</span> <span class="title function_">quickChoice</span>(nums, left, less, k);</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= more) <span class="keyword">return</span> <span class="title function_">quickChoice</span>(nums, more, right, k);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickChoice</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>, nums.<span class="property">length</span> - k);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="前-k-个高频元素">前 K 个高频元素</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/?envType=study-plan-v2&amp;envId=top-100-liked">347.
前 K 个高频元素 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>题目要求复杂度优于<code>O(nlogn)</code>，前 K
个元素很容易联想到堆这种数据结构。</p>
<p>要求频率大小，首先可以遍历数组求出每个元素出现的次数，然后用大小为<strong>K
的小根堆</strong>存储次数，使用小根堆原因是：如果新元素大于堆顶，说明在已知的前
K 个元素中，新元素能把堆顶元素踢掉（堆顶肯定不是前 K
个了），剩余的元素都大于堆顶。直到遍历完所有的频率次数组合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number[]</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span> (<span class="params">nums, k</span>) {</span><br><span class="line">  <span class="keyword">const</span> numCnt = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) {</span><br><span class="line">    <span class="keyword">if</span> (numCnt.<span class="title function_">has</span>(num)) {</span><br><span class="line">      numCnt.<span class="title function_">set</span>(num, numCnt.<span class="title function_">get</span>(num) + <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      numCnt.<span class="title function_">set</span>(num, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> heap = [];</span><br><span class="line">  <span class="comment">// 比较函数，返回负数时，parent在son前边，为0时，顺序不变，正数时parent在son后边</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">parent, son</span>) =&gt; {</span><br><span class="line">    <span class="keyword">return</span> parent.<span class="property">cnt</span> - son.<span class="property">cnt</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [num, cnt] <span class="keyword">of</span> numCnt) {</span><br><span class="line">    <span class="keyword">if</span> (heap.<span class="property">length</span> &lt; k) {</span><br><span class="line">      heap.<span class="title function_">push</span>({ num, cnt });</span><br><span class="line">      <span class="title function_">heapUp</span>(heap, heap.<span class="property">length</span> - <span class="number">1</span>, fn);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (heap[<span class="number">0</span>].<span class="property">cnt</span> &lt; cnt) {</span><br><span class="line">      heap[<span class="number">0</span>] = { num, cnt };</span><br><span class="line">      <span class="title function_">heapDown</span>(heap, <span class="number">0</span>, k, fn);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> heap.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">num</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapUp</span>(<span class="params">arr, idx, fn</span>) {</span><br><span class="line">  <span class="keyword">let</span> parentIdx;</span><br><span class="line">  <span class="comment">// 比较函数结果为正数时才交换</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="title function_">fn</span>(arr[(parentIdx = <span class="title class_">Math</span>.<span class="title function_">trunc</span>((idx - <span class="number">1</span>) / <span class="number">2</span>))], arr[idx]) &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="title function_">swap</span>(arr, parentIdx, idx);</span><br><span class="line">    idx = parentIdx;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapDown</span>(<span class="params">arr, idx, size, fn</span>) {</span><br><span class="line">  <span class="keyword">let</span> t = idx,</span><br><span class="line">    left = <span class="number">2</span> * idx + <span class="number">1</span>,</span><br><span class="line">    right = <span class="number">2</span> * idx + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; size &amp;&amp; <span class="title function_">fn</span>(arr[t], arr[left]) &gt; <span class="number">0</span>) {</span><br><span class="line">    t = left;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (right &lt; size &amp;&amp; <span class="title function_">fn</span>(arr[t], arr[right]) &gt; <span class="number">0</span>) {</span><br><span class="line">    t = right;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (t !== idx) {</span><br><span class="line">    <span class="title function_">swap</span>(arr, t, idx);</span><br><span class="line">    <span class="title function_">heapDown</span>(arr, t, size, fn);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>) {</span><br><span class="line">  <span class="keyword">const</span> t = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = t;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="跳跃游戏">跳跃游戏</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&amp;envId=top-100-liked">55.
跳跃游戏 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>贪心算法，如果能到达<code>i</code>，那么从<code>i</code>位置能到达的最远的位置是<code>i + nums[i]</code>，记为<code>maxDistance</code>，然后继续向后计算，如果<code>i + 1 &lt;= maxDistance</code>，就说明在上一步的前提下，可以到达<code>i + 1</code>位置，然后基于该位置更新<code>maxDistance</code>。初始时最远位置是
0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> maxDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= maxDistance) {</span><br><span class="line">                maxDistance = <span class="built_in">max</span>(maxDistance, i + nums[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxDistance &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="跳跃游戏-ⅱ">跳跃游戏 Ⅱ</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked">45.
跳跃游戏 II - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>贪心算法，题目中保证一定可以到最终位置。在位置<code>i</code>时，可以到达的最远位置为<code>i + nums[i]</code>，那么是不是应该跳到<code>i + nums[i]</code>位置呢？不一定。从<code>i</code>位置最远可以跳到<code>i + nums[i]</code>，如果<code>j</code>位置(<code>i &lt;= j &lt;= i + nums[i]</code>)，并且从<code>j</code>位置跳的最远距离在这个区间中时最远的，那么下一步应该跳到<code>j</code>位置，保证下一步跳的最远。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>, ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (maxPos &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) {</span><br><span class="line">            <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= maxPos; j++) {</span><br><span class="line">                end = <span class="built_in">max</span>(end, j + nums[j]);</span><br><span class="line">            }</span><br><span class="line">            i = maxPos;</span><br><span class="line">            maxPos = end;</span><br><span class="line">            ans++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="完全平方数">完全平方数</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/?envType=study-plan-v2&amp;envId=top-100-liked">279.
完全平方数 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>动态规划，<code>f[i]</code>表示<code>i</code>这个数的完全平方数的最少数量。</p>
<p>由定义可知，组成<code>i</code>这个数的完全平方数的范围肯定在<img src="https://cdn.nlark.com/yuque/__latex/9af0e2663a401c8727af031bdbd763c2.svg" alt="image">之间，因此可以遍历一遍，设<code>j</code>在这个区间内，那么如果完全平方数包含<code>j</code>这个数，剩余的数的最少数量则由<code>f[i - j * j]</code>表示，可以看成子问题，使用动态规划做。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numSquares = <span class="keyword">function</span> (<span class="params">n</span>) {</span><br><span class="line">  <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; f.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i / j; j++) {</span><br><span class="line">      f[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(f[i], f[i - j * j] + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> f.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="零钱兑换">零钱兑换</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/?envType=study-plan-v2&amp;envId=top-100-liked">322.
零钱兑换 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>思路同上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number[]</span>} <span class="variable">coins</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">number</span>} <span class="variable">amount</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">number</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> coinChange = <span class="keyword">function</span> (<span class="params">coins, amount</span>) {</span><br><span class="line">  <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Array</span>(amount + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; f.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> coin <span class="keyword">of</span> coins) {</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= coin) {</span><br><span class="line">        f[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(f[i], f[i - coin] + <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> f.<span class="title function_">at</span>(-<span class="number">1</span>) === <span class="title class_">Infinity</span> ? -<span class="number">1</span> : f.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="单词拆分">单词拆分</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&amp;envId=top-100-liked">139.
单词拆分 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>动态规划，<code>f[i]</code>表示以前<code>i</code>个字符串能否被表示出来，遍历单词字典，如果前<code>i</code>个字符串的最后的<code>word.size()</code>长度的子字符串和<code>word</code>相等，则说明可以通过<code>word</code>组成，再判断<code>f[i - word.size()]</code>能否组成即可，子问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">string</span>} <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> {<span class="type">string[]</span>} <span class="variable">wordDict</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="type">boolean</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> wordBreak = <span class="keyword">function</span> (<span class="params">s, wordDict</span>) {</span><br><span class="line">  <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">  f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= s.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> wordDict) {</span><br><span class="line">      <span class="keyword">if</span> (word.<span class="property">length</span> &gt; i) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="title function_">slice</span>(i - word.<span class="property">length</span>, i) === word) {</span><br><span class="line">        f[i] = f[i - word.<span class="property">length</span>];</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (f[i]) <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> f.<span class="title function_">at</span>(-<span class="number">1</span>);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="最长递增子序列">最长递增子序列</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/?envType=study-plan-v2&amp;envId=top-100-liked">300.
最长递增子序列 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>要求<code>O(nlogn)</code>的复杂度，考虑二分查找。</p>
<p>状态定义：<code>f[i]</code>表示长度为<code>i</code>的递增子序列的最后一个元素所有可能的取值的最小值。</p>
<p>根据定义，猜想：<code>f</code>数组是递增的。</p>
<p>反证法：如果<code>f[k] &gt;= f[i]</code>且<code>k = i - 1</code>，那么在以<code>f[i]</code>结尾的子序列中，倒数第二个元素（记为<code>v</code>）一定小于<code>f[i]</code>，以<code>v</code>为结尾的子序列长度为<code>k</code>。因为<code>f[i] &gt; v</code>且<code>f[k] &gt;= f[i]</code>所以<code>f[k] &gt; v</code>，与<code>f</code>的定义矛盾。因为长度为<code>k</code>的子序列的最后一个元素是所有可能取值里最小的，初始条件取的<code>f[k]</code>但是推出的结论<code>v &lt; f[k]</code>，说明<code>f[k]</code>不是最小，矛盾。</p>
<p>每遍历一个数，从<code>f</code>中求小于<code>num</code>的最大的位置（也就是大于等于<code>num</code>的最小的位置）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="comment">// f[i] 表示递增子序列长度为 i 时的子序列的最后一个元素的可能的最小值</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> left = <span class="number">1</span>, right = len;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">                <span class="type">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 注意这里二分的含义是 大于等于 nums[i] 的最小的，不能理解为 小于 nums[i] 的最大的</span></span><br><span class="line">                <span class="comment">// 如果找得到则 left 正好是对应的位置，如果找不到，即所有的数都小于 nums[i] ，则结果为 右边界 + 1</span></span><br><span class="line">                <span class="keyword">if</span> (f[mid] &gt;= nums[i]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            len = <span class="built_in">max</span>(len, left);</span><br><span class="line">            f[left] = nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="乘积最大子数组">乘积最大子数组</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&amp;envId=top-100-liked">152.
乘积最大子数组 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>动态规划，<code>f[i]</code>表示以<code>nums[i]</code>为结尾的子数组的最大乘积，但是这样会出现问题，因为每个元素可能会出现负值，如果是负值，那么期望前一个子数组的乘积越小越好，这与最初定义相反。因此可以维护另一个数组，存储子数组的最小乘积。</p>
<p><code>maxF[i]</code>表示子数组最大乘积，<code>minF[i]</code>表示子数组最小乘积。</p>
<p>每次遍历时最大值从<code>maxF[i - 1] * nums[i], minF[i - 1] * nums[i], nums[i]</code>中取，最小值同理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxF</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minF</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        maxF[<span class="number">0</span>] = minF[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            maxF[i] = <span class="built_in">max</span>(<span class="built_in">max</span>(maxF[i - <span class="number">1</span>] * nums[i], minF[i - <span class="number">1</span>] * nums[i]), nums[i]);</span><br><span class="line">            minF[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(minF[i - <span class="number">1</span>] * nums[i], maxF[i - <span class="number">1</span>] * nums[i]), nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(maxF.<span class="built_in">begin</span>(), maxF.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="分割等和子集">分割等和子集</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/?envType=study-plan-v2&amp;envId=top-100-liked">416.
分割等和子集 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>可以改造成背包问题，分成两个子集，两个子集的和相等，转化为找一个子集的和恰好为整个数组的和的一半，即选取一些数，这些数的和恰好等于总和的一半。</p>
<p>和原背包不同的是原背包是小于<strong>体积</strong>，这个问题是恰好等于<strong>“体积”。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) sum += num;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// f[i][j] 表示拿前 i 个物品（数）的累加和是否恰好等于 j</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(sum / <span class="number">2</span> + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; f[<span class="number">0</span>].<span class="built_in">size</span>(); i++) f[<span class="number">0</span>][i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; f.<span class="built_in">size</span>(); i++) f[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; f[<span class="number">0</span>].<span class="built_in">size</span>(); j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; f.<span class="built_in">size</span>(); i++) {</span><br><span class="line">                <span class="comment">// 如果当前要取的数小于或等于“体积”，可以选择拿或者不拿</span></span><br><span class="line">                <span class="comment">// 如果不拿，则是否恰好等于 j 取决于前 i - 1 个数的条件</span></span><br><span class="line">                <span class="comment">// 如果拿，则取决于前 i - 1 个数体积为 j - nums[i - 1] 的条件，因为要保证拿了这个数恰好等于 j，所以要减去 nums[i - 1]</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt;= j) f[i][j] = f[i - <span class="number">1</span>][j] || f[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                <span class="comment">// 如果大于，则肯定拿不了</span></span><br><span class="line">                <span class="keyword">else</span> f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f.<span class="built_in">back</span>().<span class="built_in">back</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="最长回文子串">最长回文子串</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&amp;envId=top-100-liked">5.
最长回文子串 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>如果字符串长度为 1，则肯定是回文串，直接返回，如果字符串长度为
2，则判断两个字符是否相等，如果相等，则返回，否则最长回文子串就是一个字符。</p>
<p>其余情况：</p>
<p>使用<code>f[i][j]</code>表示子串<code>s[i]...s[j]</code>是否是回文子串，是不是回文子串取决于<code>s[i] s[j]</code>是不是相等，如果不相等，则肯定不是回文的，否则判断<code>f[i + 1][j - 1]</code>是不是回文的。</p>
<p>如果<code>f[i + 1][j - 1]</code>是回文的，则<code>f[i][j]</code>是不是回文取决于在前后追加的字符是否相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>] == s[<span class="number">1</span>] ? s : <span class="built_in">string</span>(<span class="number">1</span>, s[<span class="number">0</span>]);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 初始化长度为 1 和为 2 的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            f[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) f[i - <span class="number">1</span>][i] = s[i - <span class="number">1</span>] == s[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从长度为 3 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n; len++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; i++) {</span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                f[i][j] = f[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == s[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] &amp;&amp; maxLen &lt; j - i + <span class="number">1</span>) {</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    x = i, y = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(x, maxLen);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="下一个排列">下一个排列</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/?envType=study-plan-v2&amp;envId=top-100-liked">31.
下一个排列 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>按照字典序求下一个排列，题解：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/?envType=study-plan-v2&amp;envId=top-100-liked">31.
下一个排列 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>流程：</p>
<ol type="1">
<li>从后往前找第一个<strong>相邻的升序对 (i, j)</strong></li>
<li>在 [j, end)
这个区间中<strong>从后向前</strong>寻找<strong>第一个</strong>比
<code>nums[i]</code>大的数<code>nums[k]</code></li>
<li>交换 <code>nums[i] nums[k]</code></li>
<li>再将 [j, end) 的区间逆序。</li>
</ol>
<p>总体思路：</p>
<ul>
<li>将后边<strong>较大</strong>的数与前边<strong>较小</strong>的数交换，即可以让数值更大。</li>
<li>因为是下一个排列，同时也希望<strong>增大</strong>的不是特别快。所以希望较大的数尽量的小。</li>
<li>交换完后，后续的数肯定是降序，反转改成升序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>, j = i + <span class="number">1</span>, k = j;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--, j--) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j]) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果 i &gt;= 0 说明不是最后一个排列，可以继续向下寻找，否则说明是最后一个排列，则直接跳过</span></span><br><span class="line">        <span class="comment">// 执行后续步骤就会回到第一个排列</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">for</span> (; k &gt;= j; k--) {</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[k]) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[k]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = j, b = nums.<span class="built_in">size</span>() - <span class="number">1</span>; a &lt; b; a++, b--) {</span><br><span class="line">            <span class="built_in">swap</span>(nums[a], nums[b]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="寻找重复数">寻找重复数</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">287.
寻找重复数 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>看成链表的形式，如果存在重复的数，说明链表中存在环。链表有环判断，通过快慢指针。<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表
II - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">                slow = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (fast != slow) {</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="数据流中的中位数">数据流中的中位数</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&amp;envId=top-100-liked">295.
数据流的中位数 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p>要求低时间复杂度，根据中位数的定义，使用两个优先队列（堆）存储，一个保存中位数前半部分，一个保存后半部分，加入元素时，判断属于哪一部分，加入完毕后，判断两个队列长度是否相等或者后半部分长度多一个。否则将多的数加入到另一个队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; largeHeap;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; smallHeap;</span><br><span class="line">    <span class="built_in">MedianFinder</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (smallHeap.<span class="built_in">empty</span>() || num &gt;= smallHeap.<span class="built_in">top</span>()) {</span><br><span class="line">            smallHeap.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (smallHeap.<span class="built_in">size</span>() &gt; largeHeap.<span class="built_in">size</span>() + <span class="number">1</span>) {</span><br><span class="line">                largeHeap.<span class="built_in">push</span>(smallHeap.<span class="built_in">top</span>());</span><br><span class="line">                smallHeap.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            largeHeap.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (largeHeap.<span class="built_in">size</span>() &gt; smallHeap.<span class="built_in">size</span>()) {</span><br><span class="line">                smallHeap.<span class="built_in">push</span>(largeHeap.<span class="built_in">top</span>());</span><br><span class="line">                largeHeap.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (smallHeap.<span class="built_in">size</span>() == largeHeap.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> * (smallHeap.<span class="built_in">top</span>() + largeHeap.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> smallHeap.<span class="built_in">top</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="柱状图中最大的矩形">柱状图中最大的矩形</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/?envType=study-plan-v2&amp;envId=top-100-liked">84.
柱状图中最大的矩形 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 单调递增栈</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="comment">// 分别保存第 i 个元素的左边、右边的最近的比 heights[i] 小的位置</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt;= heights[st.<span class="built_in">top</span>()]) {</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果栈空，说明左边的元素都比当前元素大，在之前的存在栈中的元素中当前元素最小</span></span><br><span class="line">            <span class="comment">// 直接设为 -1 （哨兵值，方便后期计算）</span></span><br><span class="line">            left[i] = st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(st);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt;= heights[st.<span class="built_in">top</span>()]) {</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            right[i] = st.<span class="built_in">empty</span>() ? n : st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="comment">// right[i] 和 left[i] 存储的是右边和左边的最近的最小的位置，按照</span></span><br><span class="line">            <span class="comment">// height[i] 高度寻找最大的矩形，left[i] 和 right[i] 位置的高度都无法参与构成</span></span><br><span class="line">            <span class="comment">// 因此要剔除这两个，所以需要多减一个 1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="最长有效括号">最长有效括号</h1>
<p><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">32.
最长有效括号 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a></p>
<p><code>f[i]</code>表示以<code>i</code>位置为结尾的最长有效括号长度。</p>
<p>如果<code>s[i] == '('</code>则肯定不是有效括号</p>
<p>如果<code>s[i] == ')'</code>，则如果<code>s[i - 1] == '('</code>，最后两个元素可以构成有效括号，再加上<code>f[i - 2]</code>的长度即可。则如果<code>s[i - 1] == ')'</code>，判断<code>s[i - f[i - 1] - 1] == '('</code>（判断以<code>s[i - 1]</code>结尾的有效长度的上一个位置是否是左括号），相等的话，则说明<code>[i - f[i - 1] - 1], i]</code>的范围内，两边可以组成括号，中间内部能否组成由<code>f[i - 1]</code>决定，最后加上<code>f[i - f[i - 1] - 2]</code>的长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">'('</span>) {</span><br><span class="line">                f[i] = i &gt; <span class="number">1</span> ? f[i - <span class="number">2</span>] + <span class="number">2</span> : <span class="number">2</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">')'</span>) {</span><br><span class="line">                <span class="keyword">if</span> (i - f[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i - f[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) {</span><br><span class="line">                    f[i] = f[i - <span class="number">1</span>] + (i - f[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span> ? f[i - f[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

                </div>
                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                LeetCode Hot100
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                e7148ec94978/leetcode-hot100/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    作者
                </div>
                <div class="content">yatbfm</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    发布于
                </div>
                <div class="content">2023-12-01 21:39</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    许可
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/LeetCode/">LeetCode</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/63396b583d7a/react%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"
                                   title="React基础学习"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">React基础学习</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/c197c3e8baa5/hexo%E9%85%8D%E7%BD%AE/"
                                   title="Hexo配置"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">Hexo配置</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-text">盛最多水的容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">三数之和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-text">最长连续序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-text">接雨水</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-text">无重复字符的最长子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">和为 K 的子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">滑动窗口最大值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-text">最小覆盖子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-text">最大子数组和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-text">轮转数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="nav-text">缺失的第一个正数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-text">旋转图像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-text">相交链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-text">回文链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-text">环形链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-text">删除链表的倒数第 N 个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text">两两交换链表中的节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">K 个一组翻转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">随机链表的复制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">排序链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">合并 K 个升序链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-lru-%E7%BC%93%E5%AD%98"><span class="nav-text">实现 LRU 缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">二叉树的层序遍历</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">将有序数组转为平衡二叉搜索树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">验证是否是二叉搜索树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">二叉搜索树第 K 小的元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-text">二叉树的右视图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-text">二叉树展开为链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">从前序遍历和中序遍历构造二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-%E2%85%B2"><span class="nav-text">路径总和 Ⅲ</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text">二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-text">二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-text">岛屿数量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="nav-text">腐烂的橘子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="nav-text">课程表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-trie-%E6%A0%91"><span class="nav-text">实现 Trie 树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">全排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%90%E9%9B%86"><span class="nav-text">子集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-text">电话号码的字母组合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-text">组合总和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-text">括号生成</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-text">单词搜索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-text">分割回文串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#n-%E7%9A%87%E5%90%8E"><span class="nav-text">N 皇后</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-text">搜索插入位置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="nav-text">搜索二维矩阵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-text">排序数组中查找第一个和最后一个位置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-text">搜索旋转排序数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">寻找两个正序数组的中位数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-text">最小栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="nav-text">字符串解码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-text">方法 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-2"><span class="nav-text">方法 2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-text">每日温度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">数组中第 K 个最大的元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-text">前 K 个高频元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-text">跳跃游戏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-%E2%85%B1"><span class="nav-text">跳跃游戏 Ⅱ</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-text">完全平方数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-text">零钱兑换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-text">单词拆分</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">最长递增子序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">乘积最大子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-text">分割等和子集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-text">下一个排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-text">寻找重复数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">数据流中的中位数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="nav-text">柱状图中最大的矩形</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-text">最长有效括号</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2025
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">yatbfm</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-text">盛最多水的容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">三数之和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-text">最长连续序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-text">接雨水</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-text">无重复字符的最长子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">和为 K 的子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">滑动窗口最大值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-text">最小覆盖子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-text">最大子数组和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-text">轮转数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="nav-text">缺失的第一个正数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-text">旋转图像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-text">相交链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-text">回文链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-text">环形链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-text">删除链表的倒数第 N 个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text">两两交换链表中的节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">K 个一组翻转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">随机链表的复制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">排序链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">合并 K 个升序链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-lru-%E7%BC%93%E5%AD%98"><span class="nav-text">实现 LRU 缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">二叉树的层序遍历</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">将有序数组转为平衡二叉搜索树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">验证是否是二叉搜索树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">二叉搜索树第 K 小的元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-text">二叉树的右视图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-text">二叉树展开为链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">从前序遍历和中序遍历构造二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-%E2%85%B2"><span class="nav-text">路径总和 Ⅲ</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text">二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-text">二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-text">岛屿数量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="nav-text">腐烂的橘子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="nav-text">课程表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-trie-%E6%A0%91"><span class="nav-text">实现 Trie 树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">全排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%90%E9%9B%86"><span class="nav-text">子集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-text">电话号码的字母组合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-text">组合总和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-text">括号生成</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-text">单词搜索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-text">分割回文串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#n-%E7%9A%87%E5%90%8E"><span class="nav-text">N 皇后</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-text">搜索插入位置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="nav-text">搜索二维矩阵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-text">排序数组中查找第一个和最后一个位置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-text">搜索旋转排序数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">寻找两个正序数组的中位数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-text">最小栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="nav-text">字符串解码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-text">方法 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-2"><span class="nav-text">方法 2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-text">每日温度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">数组中第 K 个最大的元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-text">前 K 个高频元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-text">跳跃游戏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-%E2%85%B1"><span class="nav-text">跳跃游戏 Ⅱ</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-text">完全平方数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-text">零钱兑换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-text">单词拆分</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">最长递增子序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">乘积最大子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-text">分割等和子集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-text">下一个排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-text">寻找重复数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">数据流中的中位数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="nav-text">柱状图中最大的矩形</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-text">最长有效括号</span></a></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->

    
<script src="/js/local-search.js"></script>



<!-- lazyload -->


<div class="">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        
            
<script src="/js/post/copyright-info.js"></script>

        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->

    
<script src="//cdn.jsdelivr.net/npm/mermaid@10.5.0/dist/mermaid.min.js"></script>






<!-- pjax -->



    
        
            
<script class="custom-inject-js" src="/js/custom.js" data-pjax></script>

        
    

</body>
</html>
